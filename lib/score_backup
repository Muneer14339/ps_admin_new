/////Score  Backup
//FUNCTION_ATTRIBUTE
//        int32_t score(uint8_t *input_buffer, int platform, int _, int frame_width, int frame_height, uint8_t *output_buffer, uint8_t *detect_only_buffer, char *output_path)
//{
//long long start = get_now();
//
//int tz_frame_width, tz_frame_height;
//
//tz_frame_height = frame_height;
//tz_frame_width = frame_width;
//
//TargetZoneDetector tz_detector(tz_frame_height, tz_frame_width);
//Scorer scorer;
//
//int32_t prev_frame_index = -1;
//int32_t frame_index = 0;
//int32_t last_score_out = -1;
//int32_t detect_only = 1;
//
//int max_size = 1024;
//platform_log("Frame width: %d frame height: %d\n", frame_width, frame_height);
//
//uint8_t *input_buffer_ = input_buffer;
//uint8_t *output_buffer_ = output_buffer;
//uint8_t *detect_only_buffer_ = detect_only_buffer;
//is_running = true;
//int32_t fps = -1;
//while (true)
//{
//// Stop signal
//if (!is_running)
//break;
//
//
//while (is_paused) {
//sleep_ms(100);
//}
//
//input_mtx.lock();
//input_buffer = input_buffer_;
//frame_index = readInt32FromBuffer(input_buffer);
//if (frame_index < 0 || frame_index == prev_frame_index)
//{
//input_mtx.unlock();
//// sleep
//sleep_ms(40);
//continue;
//}
//last_score_out = -1;
//
//prev_frame_index = frame_index;
//
//// Read fps
//input_buffer += sizeof(int32_t);
//fps = readInt32FromBuffer(input_buffer);
//
//// read last_score
//input_buffer += sizeof(int32_t);
//int32_t last_score_ = readInt32FromBuffer(input_buffer);  // ignore
//
//// read num_bytes
//input_buffer += sizeof(int32_t);
//int n_bytes = readInt32FromBuffer(input_buffer);
//
//input_buffer += sizeof(int32_t);
//cv::Mat frame;
//std::vector<uint8_t> tmp(input_buffer, input_buffer + n_bytes);
//frame = cv::imdecode(tmp, cv::IMREAD_UNCHANGED);
//if (frame.empty())
//{
//platform_log("Could not decode frame\n");
//input_mtx.unlock();
//sleep_ms(40);
//continue;
//}
//
//input_mtx.unlock();
//
//if (frame.empty())
//{
//break;
//}
//
//int h = frame.rows;
//int w = frame.cols;
//if (w > frame_width) {
//int pad_x = (w - frame_width) / 2;
//cv::Rect roi(pad_x, 0, frame_width, frame_height);
//frame = frame(roi);
//}
//double ratio = static_cast<double>(max_size) / std::max(h, w);
//if (ratio < 1)
//{
//int new_h = static_cast<int>(ratio * h);
//int new_w = static_cast<int>(ratio * w);
//cv::resize(frame, frame, cv::Size(new_w, new_h));
//}
//
//frame_index++;
//
//double t0 = static_cast<double>(cv::getTickCount());
//cv::Mat frame_gray;
//cv::cvtColor(frame, frame_gray, cv::COLOR_BGR2GRAY);
//
//if (!tz_detector.is_ready()){
//tz_detector.prepare(frame, frame_gray);
//}
//else{
//if (frame.empty() || frame_gray.empty()) {
//platform_log("invalid frame");
//} else {
//auto numCircles = tz_detector.process(frame, frame_gray);
//if (numCircles > 0 && !tz_detector.is_shifted()) {
//auto target_zone = tz_detector.get_target_zone_info();
//std::vector <std::pair<cv::Point, int>> circles = target_zone["circles"];
//
//if (!circles.empty()) {
//if (!is_running)
//break;
//
//while (is_paused) {
//sleep_ms(100);
//}
//
//// pls help remove other platform_log in score
//platform_log("number of circles: %d fps: %d frame_index %d frame_width %d frame_height: %d", circles.size(), fps, frame_index, frame_width, frame_height);
//// int timestamp = static_cast<int>(cap.get(cv::CAP_PROP_POS_MSEC));
//
//detect_only_mtx.lock();
//detect_only = readInt32FromBuffer(detect_only_buffer);
//detect_only_mtx.unlock();
//
//if (!detect_only) {
//float timestamp = static_cast<float>(frame_index) / fps;
//last_score_out = scorer.process(frame, frame_gray, target_zone, timestamp);
//} else {
//platform_log("circleTest detect only=else: %d", detect_only);
//}
//for (const auto &circle: circles)
//{
//if (circle.second > 0) {
//platform_log("circleTest second is grater then zero==if\n");
//cv::circle(frame, circle.first, circle.second, cv::Scalar(255, 255, 255), 2);
//}else{
//platform_log("circleTest second is grater then zero==else\n");
//}
//}
//}else{
//platform_log("circleTest empty = else\n");
//}
//}else {
//platform_log("circleTest numCircles = else\n");
//}
//
//}
//}
//
//int total_score = scorer.get_total_score();
//int last_score = scorer.get_last_score();
//
//double t1 = static_cast<double>(cv::getTickCount());
//int runningFps = cvRound(cv::getTickFrequency() / (t1 - t0));
//
//std::string last_score_txt = "last score: " + (last_score < 0 ? "_" : std::to_string(last_score));
////std::string text = "#frame " + std::to_string(frame_index) + " fps: " + std::to_string(runningFps) + " " + last_score_txt + " total score: " + std::to_string(total_score);
//std::string text = "#frame " + std::to_string(frame_index) + " fps: " + std::to_string(runningFps);
//std::string history_text = scorer.get_history_as_string();
//cv::putText(frame, text, cv::Point(50, 50), cv::FONT_HERSHEY_COMPLEX, 0.7, cv::Scalar(0, 255, 0), 1, cv::LINE_AA);
////cv::putText(frame, history_text, cv::Point(50, 100), cv::FONT_HERSHEY_COMPLEX, 0.7, cv::Scalar(0, 255, 0), 1, cv::LINE_AA);
//
//if (ratio < 1)
//{
//cv::resize(frame, frame, cv::Size(frame_width, frame_height));
//}
//
//// |frame_index|FPS|num_bytes|frame_bytes|
//mtx.lock();
//output_buffer = output_buffer_;
//
//// frame_index
//std::memcpy(output_buffer, &frame_index, sizeof(int32_t));
//output_buffer += sizeof(int32_t);
//
//// FPS
//std::memcpy(output_buffer, &fps, sizeof(int32_t));
//output_buffer += sizeof(int32_t);
//
//int32_t tmp_last_score = last_score_out;
//std::memcpy(output_buffer, &tmp_last_score, sizeof(int32_t));
//output_buffer += sizeof(int32_t);
//
//// num_bytes + frame_bytes
//std::vector<uchar> encoded_image_bytes;
//cv::imencode(".png", frame, encoded_image_bytes);
//
//// num_bytes
//int32_t frame_bytes = encoded_image_bytes.size();
//std::memcpy(output_buffer, &frame_bytes, sizeof(int32_t));
//output_buffer += sizeof(int32_t);
//
//// frame_bytes
//std::memcpy(output_buffer, encoded_image_bytes.data(), frame_bytes);
//
//mtx.unlock();
//}
//platform_log("total frames: %d\n", frame_index);
//
//int evalInMillis = static_cast<int>(get_now() - start);
//
////frame.release();
////frame_gray.release();
////tz_detector.clear();
////cv::destroyAllWindows();
//
//
//platform_log("Processing done in %dms\n", evalInMillis);
//
//is_running = false;
//return 0;
//}
//
///////////////////////// ///////// ///////// /////////// /////////// ////////////// //////////
//
//#include <opencv2/opencv.hpp>
//#include <chrono>
//#include <map>
//
//#include <algorithm>
//#include <bitset>
//#include <fstream>
//#include <iostream>
//#include <numeric>
//#include <vector>
//#include <mutex>
////#include <omp.h>
//
//
//#if defined(WIN32) || defined(_WIN32) || defined(__WIN32)
//#define IS_WIN32
//#endif
//
//#ifdef __ANDROID__
//#include <android/log.h>
//#endif
//
//#ifdef IS_WIN32
//#include <windows.h>
//#endif
//
//#if defined(__GNUC__)
//// Attributes to prevent 'unused' function from being removed and to make it visible
//#define FUNCTION_ATTRIBUTE __attribute__((visibility("default"))) __attribute__((used))
//#elif defined(_MSC_VER)
//// Marking a function for export
//#define FUNCTION_ATTRIBUTE __declspec(dllexport)
//#endif
//
//// using namespace cv;
//// using namespace std;
//
//
//bool is_running = false;
//bool is_paused = false;
//
//
//void platform_log(const char *fmt, ...)
//{
//    va_list args;
//    va_start(args, fmt);
//#ifdef __ANDROID__
//    __android_log_vprint(ANDROID_LOG_VERBOSE, "ndk", fmt, args);
//#elif defined(IS_WIN32)
//    char *buf = new char[4096];
//    std::fill_n(buf, 4096, '\0');
//    _vsprintf_p(buf, 4096, fmt, args);
//    OutputDebugStringA(buf);
//    delete[] buf;
//#else
//    vprintf(fmt, args);
//#endif
//    va_end(args);
//}
//
//#define PIXEL_SCALE 100 // ���ݳߴ磬���������ֵ����
//
//#define MAT_NUMBER 15 // һ��6*6���������15��������ʾ
//
//class Node_FC
//{
//public:
//    Node_FC();
//    Node_FC(int x, int y, int scale);
//    cv::Point Location;
//    Node_FC *nextAddress; // the address of the next point
//    Node_FC *lastAddress; // the address of the last point
//    int edgeID;
//    double nodeMat[MAT_NUMBER];
//    double nodesMat[MAT_NUMBER]; // The sum of the nodeMat
//
//public:                                   // Some Linking Functions
//    inline void nextIs(Node_FC *next_dot) // Link to the next point
//    {
//        if (next_dot != NULL)
//        {
//            nextAddress = next_dot;
//            next_dot->lastAddress = this;
//            next_dot->edgeID = this->edgeID + 1;
//            for (int k = 0; k < MAT_NUMBER; k++)
//            {
//                next_dot->nodesMat[k] = nodesMat[k] + next_dot->nodeMat[k];
//            }
//        }
//        else
//        {
//            nextAddress = NULL;
//        }
//    }
//    inline void lastIs(Node_FC *last_dot) // Link to the last point
//    {
//        if (last_dot != NULL)
//        {
//            lastAddress = last_dot;
//            last_dot->nextAddress = this;
//            last_dot->edgeID = this->edgeID - 1;
//            for (int k = 0; k < MAT_NUMBER; k++)
//            {
//                last_dot->nodesMat[k] = this->nodesMat[k] - last_dot->nodeMat[k];
//            }
//        }
//        else
//        {
//            lastAddress = NULL;
//        }
//    }
//    inline void negMatrix()
//    {
//        for (int i = 0; i < MAT_NUMBER; i++)
//        {
//            nodesMat[i] *= -1;
//        }
//    }
//    inline void setFirst()
//    {
//        lastAddress = NULL;
//        nextAddress = NULL;
//        edgeID = 1;
//        for (int k = 0; k < MAT_NUMBER; k++)
//            nodesMat[k] = nodeMat[k];
//    }
//    inline void swapLink()
//    {
//        Node_FC *temp = lastAddress;
//        lastAddress = nextAddress;
//        nextAddress = temp;
//    }
//};
//
//#define FLED_EDGECONTOURS 0x21
//#define FLED_FSAARCCONTOURS 0x22
//#define FLED_FSALINES 0x23
//#define FLED_FSAARCSLINKMATRIX 0x24
//#define FLED_DPCONTOURS 0x25
//
//// �����4�����������F��������Զ��C���������
//#define FLED_GROUPING_IBmA1_IAnB1 0x00 // ��ʼ����
//#define FLED_GROUPING_FBmA1_FAnB1 0x00 // ������Զ��β��Զ
//#define FLED_GROUPING_FBmA1_CAnB1 0x01 // ���������β��Զ
//#define FLED_GROUPING_CBmA1_FAnB1 0x10 // ������Զ��β���
//#define FLED_GROUPING_CBmA1_CAnB1 0x11 // ���������β���
//#define FLED_GROUPING_CAnB1 0x01       // �������
//#define FLED_GROUPING_CBmA1 0x10       // β���
//
//// ����������У�ȥ���˸�����ɫ�ж��Ƿ����ӵ���������Ϊ����ȥ���ˣ��ں����ȫ�ַ���Ҳ�����ºϲ�һ�ν����жϣ���������kd���㷨����
//// ����������⡣
//
//#define FLED_SEARCH_LINKING true
//#define FLED_SEARCH_LINKED false
//
//// ---------------------�����л�����-----------------------
//// ����ӦRDP�㷨
//#define ADAPT_APPROX_CONTOURS 1
//// ����Ӧ���ʹ����㷨
//#define DEFINITE_ERROR_BOUNDED 1
//// ��Բ��֤����
//#define FASTER_ELLIPSE_VALIDATION 0
//
//// ѡ����Բ�����㷨
//#define NONE_CLUSTER_METHOD 0
//#define PRASAD_CLUSTER_METHOD 1
//#define OUR_CLUSTER_METHOD 2
//#define SELECT_CLUSTER_METHOD PRASAD_CLUSTER_METHOD
//// ------------------------------------------------------
//
//// �Ƿ���Ҫͳ��ʱ��
//#define DETAIL_BREAKDOWN
//
//struct SORTDATA;
//bool cmp(SORTDATA &A, SORTDATA &B);
//template <class T>
//class GroupPart
//{
//public:
//    GroupPart()
//    {
//        _data = NULL;
//        data_size = 0;
//    }
//    GroupPart(int num)
//    {
//        _data = new T[num];
//        data_size = num;
//    }
//    void Update(int new_num)
//    {
//        use_size = new_num;
//        if (new_num > data_size)
//        {
//            if (_data != NULL)
//                delete[] _data;
//            _data = new T[new_num];
//            data_size = new_num;
//        }
//        memset(_data, 0, sizeof(T) * new_num);
//    }
//    void clean()
//    {
//        memset(_data, 0, sizeof(T) * use_size);
//    }
//    int memsize() { return data_size; }
//    int usesize() { return use_size; }
//    T *GetDataPoint() const { return _data; }
//    void release()
//    {
//        if (_data != NULL)
//        {
//            delete[] _data;
//            _data = NULL;
//        }
//    }
//
//    T *operator[](int idx) { return _data + idx; }
//
//protected:
//    T *_data;
//    int data_size;
//    int use_size;
//};
//
//struct SORTDATA
//{
//    double val; // ������ϵ����ص����
//    int idx_l;  // �����ӱ�ǩ
//    int idx_r;  // ���ӱ�ǩ
//};
//
//// ����4�������ȷ��һ���������䣬
//class ArcSearchRegion
//{
//public:
//    // ������������
//    void create(cv::Point *l1, cv::Point *l2, cv::Point *l3, cv::Point *l4)
//    {
//        A_1 = *l1, A_2 = *l2, A__2 = *l3, A__1 = *l4;
//        l_12 = A_1 - A_2, l__11 = A__1 - A_1, l_1_2 = A__1 - A__2;
//    }
//    bool isInSearchRegion(const cv::Point *dst_point) const
//    {
//        cv::Point l_t;
//
//        l_t.x = dst_point->x - A_1.x, l_t.y = dst_point->y - A_1.y;
//        if (l_12.x * l_t.y - l_12.y * l_t.x < 0)
//            return false;
//        if (l_t.x * l__11.y - l_t.y * l__11.x < 0)
//            return false;
//
//        l_t.x = dst_point->x - A__1.x, l_t.y = dst_point->y - A__1.y;
//        if (l_t.x * l_1_2.y - l_t.y * l_1_2.x < 0)
//            return false;
//        return true;
//    }
//    bool isInSearchRegion(ArcSearchRegion *dst_asr) const
//    {
//        if (!isInSearchRegion(&dst_asr->A_1))
//            return false;
//        if (!isInSearchRegion(&dst_asr->A__1))
//            return false;
//        return true;
//    }
//
//    // return the length of (A_1 - A_2), the distance is L-1 norm.
//    int length_l_12_L1()
//    {
//        return abs(l_12.x) + abs(l_12.y);
//    }
//
//    // return the length of (A_{-1} - A_1), the distance is L-1 norm.
//    int length_l__11_L1()
//    {
//        return abs(l__11.x) + abs(l__11.y);
//    }
//
//    // return the length of (A_{-1} - A_{-2}), the distance is L-1 norm.
//    int length_l_1_2_L1()
//    {
//        return abs(l_1_2.x) + abs(l_1_2.y);
//    }
//
//public:
//    cv::Point A_1;  // A_1
//    cv::Point A_2;  // A_2
//    cv::Point A__2; // A_{-2}
//    cv::Point A__1; // A_{-1}
//
//    cv::Point l_12;  // A_1 - A_2
//    cv::Point l__11; // A_{-1} - A_1
//    cv::Point l_1_2; // A_{-1} - A_{-2}
//};
//
//#define dIDX(i, j) i *dCOLS + j
//#define iIDX(i, j) i *iCOLS + j
//#define OutOfRange(x, y) (x < 0 || y < 0 || x >= iROWS || y >= iCOLS)
//
//#define MIN_DP_CONTOUR_NUM 3
//
//#define VALIDATION_NUMBER 360
//
//// #define MAX_COMBINATION_ARCS 8
//
//// t1 = cv::getTickCount();
//// t2 = (double)cv::getTickCount();
//// sum_time += 1;// (t2 - t1) * 1000 / cv::getTickFrequency();
//
//using cv::Mat;
//using cv::Point;
//using cv::Point2f;
//
//using std::cout;
//using std::endl;
//using std::string;
//using std::vector;
//
//class FLED
//{
//public:
//    FLED(int drows, int dcols);
//    void SetParameters(double theta_fsa, double length_fsa, double T_val);
//    vector<cv::RotatedRect> detEllipses;
//    ~FLED()
//    {
//        release();
//    }
//
//    void SetParameters(double T_dp, double theta_fsa, double length_fsa, double T_val, int grad_num);
//    void initFrame();
//    void release(); // release data;
//    bool checkInputImage(int rows, int cols);
//    void run_FLED(Mat Img_G);
//    void run_AAMED_WithoutCanny(Mat Img_G);
//
//public: // Draw Data and Write Information Functions
//    // void drawEdgeContours();
//    // void drawDPContours();
//    // void drawFSA_ArcContours();
//    // void drawEllipses();
//    // void drawFLED(Mat ImgC, double use_time = -1);
//    // void drawFLED(Mat ImgG, string savepath);
//    // void writeFLED(string filepath, string filename, double useTime);
//    void showDetailBreakdown(cv::Vec<double, 10> &detDetailTime, int needDisplay = 1);
//    void showDatasetBreakdown();
//    // void writeDetailData();
//
//public:
//    void calCannyThreshold(cv::Mat &ImgG, int &low, int &high); // Adaptive Canny thresholds
//    int getNumDets()
//    {
//        return detEllipses.size();
//    }
//
//public: // The public functions that used for Python.
//    int run_FLED(unsigned char *_img_G, int irows, int icols)
//    {
//        Mat Img_G(irows, icols, CV_8UC1, _img_G);
//        run_FLED(Img_G);
//        return detEllipses.size();
//    }
//    void UpdateResults(float *_data)
//    {
//        for (int i = 0; i < detEllipses.size(); i++)
//        {
//            _data[i * 6 + 0] = detEllipses[i].center.x;
//            _data[i * 6 + 1] = detEllipses[i].center.y;
//            _data[i * 6 + 2] = detEllipses[i].size.width;
//            _data[i * 6 + 3] = detEllipses[i].size.height;
//            _data[i * 6 + 4] = detEllipses[i].angle;
//            _data[i * 6 + 5] = detEllipseScore[i];
//        }
//    }
//    // void drawAAMED(unsigned char *_img_G, int irows, int icols)
//    // {
//    //     Mat img_G = Mat(irows, icols, CV_8UC1, _img_G).clone();
//    //     cvtColor(img_G, img_G, cv::COLOR_GRAY2BGR);
//    //     drawFLED(img_G, 0);
//    // }
//    // void drawAAMED(unsigned char *_img_G, int irows, int icols, cv::Vec3b *_outImg)
//    // {
//    //     Mat img_G = Mat(irows, icols, CV_8UC1, _img_G).clone();
//    //     Mat img_O = Mat(irows, icols, CV_8UC3, _outImg);
//    //     cvtColor(img_G, img_G, cv::COLOR_GRAY2BGR);
//    //     drawFLED(img_G, 0);
//    //     cv::waitKey(0);
//    // }
//
//protected:
//    void findContours(uchar *_edge);
//    void BoldEdge(uchar *_edge, const vector<vector<Point>> &edge_Contours);
//    void FSA_Segment(vector<Point> &dpContour);
//
//    void Arcs_Grouping(vector<vector<Point>> &fsaarcs);
//    void CreateArcSearchRegion(vector<vector<Point>> &fsaarcs);
//
//    vector<vector<Point>> edgeContours, dpContours, FSA_ArcContours;
//
//    vector<double> detEllipseScore;
//
//    vector<ArcSearchRegion> asrs;
//
//    void SegmentAnArc(vector<Point> &AdpContour);
//    vector<vector<Point>> StrongArcs;
//    vector<vector<Point>> WeakArcs;
//    void SortArcs(vector<vector<Point>> &detArcs);
//
//private:          // The list of parameters.
//    double _T_dp; // Useless
//    double _theta_fsa;
//    double _length_fsa;
//    double _T_val;
//    double _T_gradnum; // Useless
//    // The list of adaptive parameters
//    double _T_edge_num;  // Independent of image size
//    double _T_min_minor; // Independent of image size
//
//private:
//    double sum_time;
//    int fitnum;
//    int case_stat[4];
//    char isBIDIR;
//
//    int dROWS, dCOLS, iROWS, iCOLS;
//    // Part of Canny
//    Mat imgCanny;
//    // Part of FindContours
//    void findContour(const int Wise[8][2], const int antiWise[8][2], uchar *Edge, int x, int y);
//
//    void clockwiseContour(vector<Point> &antiContour);
//
//    vector<Point> oneContour;
//    vector<Point> oneContourOpp;
//
//    Node_FC *data;
//    // KD-Trees. KD is used for high speed
//    void getArcs_KDTrees(vector<vector<Point>> &arcs);
//
//    vector<float> query_arcs;
//    Mat source_arcs, indices_arcs, dist_arcs;
//
//    // Ellipse Fitting Varaies
//    Mat dls_C, dls_D, dls_V, dls_D2, dls_V2, dls_X;
//    void fitEllipse(double *data, double &error, cv::RotatedRect &res);
//    void ElliFit(double *data, double &error, cv::RotatedRect &res);
//
//    // The part of arc adjacency matrix (AAM)
//    GroupPart<char> LinkMatrix;
//    struct linkArc
//    {
//        int idx;
//        vector<int> idx_linking;
//        vector<int> idx_linked;
//        vector<int> idx_notlink;
//        void clear()
//        {
//            idx_linking.clear();
//            idx_linked.clear();
//            idx_notlink.clear();
//        }
//        int findNextLinking(int idx_start)
//        {
//            int linking_num = (int)idx_linking.size();
//            return idx_start + 1 < linking_num ? idx_start + 1 : -1;
//        }
//        int findNextLinked(int idx_start)
//        {
//            int linked_num = (int)idx_linked.size();
//            return idx_start + 1 < linked_num ? idx_start + 1 : -1;
//        }
//    };
//    std::vector<linkArc> lA;
//    void getlinkArcs(const char *_linkMatrix, int arc_num);
//
//    // Extracting the arc combinations according to the adjacency matrix
//    vector<int> temp;
//    std::vector<unsigned char> _arc_grouped_label; // If the value of ith is 1, the ith arc has been combined in an arc combination
//    cv::Vec<double, MAT_NUMBER> fitArcTemp;
//
//    vector<vector<int>> search_group[2];
//    vector<cv::Vec<double, MAT_NUMBER>> search_arcMats[2];
//    void init_fitmat(double *basic_fitmat, double *init_fitmat, int num);
//    void push_fitmat(double *basic_fitmat, double *add_fitmat, int num);
//    void pop_fitmat(double *basic_fitmat, double *minus_fitmat, int num);
//
//    GroupPart<unsigned char> visited; // The ith value represent whether ith arc is visited or not.
//    GroupPart<unsigned char> searched;
//
//    vector<cv::Vec<double, MAT_NUMBER>> ArcFitMat;
//    void GetArcMat(vector<cv::Vec<double, MAT_NUMBER>> &arcfitmat, vector<vector<Point>> &fsa_arc);
//
//    GroupPart<SORTDATA> fitComb_LR;
//    typedef GroupPart<SORTDATA> GPSD;
//    void sortCombine(GPSD &fitComb, vector<cv::Vec<double, MAT_NUMBER>> arcMats[2], vector<vector<int>> s_group[2]);
//
//    // PAS, AAS, BCV
//    void PosteriorArcsSearch(int point_idx);                                                                                                                            // Step: Search Linking
//    void AnteriorArcsSearch(int point_idx);                                                                                                                             // Step: Search Linked
//    void BiDirectionVerification(GPSD &fitComb, vector<cv::Vec<double, MAT_NUMBER>> fitMats[2], vector<vector<int>> link_group[2], vector<unsigned char> &arc_grouped); // Step: Find Valid Combination
//
//    void PosteriorArcsSearch2(int point_idx); // Step: Search Linking
//    void AnteriorArcsSearch2(int point_idx);  // Step: Search Linked
//
//    bool FittingConstraint(double *_linkingMat, double *_linkedMat, cv::RotatedRect &fitres);
//    bool Validation(cv::RotatedRect &res, double *detScore);
//    bool fastValidation(cv::RotatedRect &res, double *detScore);
//    double vld_use_time;
//
//    // Validation Data
//    float vldBaseData[VALIDATION_NUMBER][2];
//    // double vldBaseDataX[VALIDATION_NUMBER], vldBaseDataY[VALIDATION_NUMBER], sample_x[VALIDATION_NUMBER], sample_y[VALIDATION_NUMBER], grad_x[VALIDATION_NUMBER], grad_y[VALIDATION_NUMBER], sample_weight[VALIDATION_NUMBER];
//    float vldBaseDataX[VALIDATION_NUMBER], vldBaseDataY[VALIDATION_NUMBER], sample_x[VALIDATION_NUMBER], sample_y[VALIDATION_NUMBER], grad_x[VALIDATION_NUMBER], grad_y[VALIDATION_NUMBER], sample_weight[VALIDATION_NUMBER];
//
//    static void ClusterEllipses(std::vector<cv::RotatedRect> &detElps, vector<double> &detEllipseScore);
//
//private:
//    cv::flann::LinearIndexParams indexParams;
//    cv::flann::Index kdTree_Arcs;
//
//protected:
//    // the region constraint and curvature constraint are used to calculate Lij in four cases
//    char Group4FAnB1_FBmA1(Point vecFet[8], const Point *const *l1, const Point *const *l2, const ArcSearchRegion *const asri, const ArcSearchRegion *const asrk) const
//    {
//        int linkval[2];
//
//        if (!RegionConstraint(asri, asrk))
//            return -1;
//        if (!RegionConstraint(asrk, asri))
//            return -1;
//        return 1;
//
//        // if (!CONSTRAINT_GLOBAL_REGION(vecFet, l1, l2[0]))
//        //	return -1;
//        // if (!CONSTRAINT_GLOBAL_REGION(vecFet, l1, l2[3]))
//        //	return -1;
//        vecFet[5].x = l2[3]->x - l2[2]->x;
//        vecFet[5].y = l2[3]->y - l2[2]->y;
//        vecFet[4].x = l2[1]->x - l2[0]->x;
//        vecFet[4].y = l2[1]->y - l2[0]->y;
//
//        linkval[0] = CONSTRAINT_GLOABL_CURVATURE(vecFet, 1);
//        if (linkval[0] == -1)
//            return -1;
//        linkval[1] = CONSTRAINT_GLOABL_CURVATURE(vecFet, 2);
//        if (linkval[1] == -1)
//            return -1;
//        if (linkval[0] == 1 || linkval[1] == 1)
//            return 1;
//        return 0;
//    }
//    char Group4FAnB1_FBmA1(Point vecFet[8], const Point *const *l1, const Point *const *l2) const
//    {
//        int linkval[2];
//        if (!CONSTRAINT_GLOBAL_REGION(vecFet, l1, l2[0]))
//            return -1;
//        if (!CONSTRAINT_GLOBAL_REGION(vecFet, l1, l2[3]))
//            return -1;
//        vecFet[5].x = l2[3]->x - l2[2]->x;
//        vecFet[5].y = l2[3]->y - l2[2]->y;
//        vecFet[4].x = l2[1]->x - l2[0]->x;
//        vecFet[4].y = l2[1]->y - l2[0]->y;
//
//        linkval[0] = CONSTRAINT_GLOABL_CURVATURE(vecFet, 1);
//        if (linkval[0] == -1)
//            return -1;
//        linkval[1] = CONSTRAINT_GLOABL_CURVATURE(vecFet, 2);
//        if (linkval[1] == -1)
//            return -1;
//        if (linkval[0] == 1 || linkval[1] == 1)
//            return 1;
//        return 0;
//    }
//    char Group4CAnB1_FBmA1(Point vecFet[8], const Point *const *l1, const Point *const *l2) const
//    {
//        Point l1_l2_O, vecl[2];
//        l1_l2_O.x = (vecFet[3].x >> 1) + l1[3]->x;
//        l1_l2_O.y = (vecFet[3].y >> 1) + l1[3]->y;
//        vecl[0].x = l1_l2_O.x - l1[2]->x;
//        vecl[0].y = l1_l2_O.y - l1[2]->y;
//        vecl[1].x = l2[1]->x - l1_l2_O.x;
//        vecl[1].y = l2[1]->y - l1_l2_O.y;
//        if (!CONSTRAINT_NEIBOR_FSA(vecl))
//            return -1;
//        vecFet[5].x = l2[3]->x - l2[2]->x;
//        vecFet[5].y = l2[3]->y - l2[2]->y;
//        if (!CONSTRAINT_NEIBOR_TAIL(vecFet))
//            return -1;
//
//        return 1;
//    }
//    char Group4FAnB1_CBmA1(Point vecFet[8], const Point *const *l1, const Point *const *l2) const
//    {
//        if (!CONSTRAINT_GLOBAL_REGION(vecFet, l1, l2[0]))
//            return -1;
//        vecFet[5].x = l2[3]->x - l2[2]->x;
//        vecFet[5].y = l2[3]->y - l2[2]->y;
//        vecFet[4].x = l2[1]->x - l2[0]->x;
//        vecFet[4].y = l2[1]->y - l2[0]->y;
//        if (CONSTRAINT_GLOABL_CURVATURE(vecFet, 1) == -1)
//            return -1;
//        return 1;
//    }
//    char Group4CAnB1_CBmA1(Point vecFet[8], const Point *const *l1, const Point *const *l2) const
//    {
//        Point l1_l2_O, vecl[2];
//        l1_l2_O.x = (vecFet[3].x >> 1) + l1[3]->x;
//        l1_l2_O.y = (vecFet[3].y >> 1) + l1[3]->y;
//        vecl[0].x = l1_l2_O.x - l1[2]->x;
//        vecl[0].y = l1_l2_O.y - l1[2]->y;
//        vecl[1].x = l2[1]->x - l1_l2_O.x;
//        vecl[1].y = l2[1]->y - l1_l2_O.y;
//        if (!CONSTRAINT_NEIBOR_FSA(vecl)) // These two arcs do not satisfy the curvature contraint, i.e. Lij = -1;
//            return -1;
//        else
//            return 1;
//    }
//
//    // Neighbor Grouping: FSA Constraint
//    bool CONSTRAINT_NEIBOR_FSA(const Point ni[2]) const
//    {
//        const double Theta_fsa = _theta_fsa, Length_fsa = _length_fsa, Length_fsa_inv = 1 / _length_fsa;
//
//        cv::Point2d FSA;
//        double l_Ai_1Ai = ni[0].x * ni[0].x + ni[0].y * ni[0].y, tp[3];
//        FSA.x = (ni[0].x * ni[1].x + ni[0].y * ni[1].y) / l_Ai_1Ai;
//        FSA.y = (ni[1].x * ni[0].y - ni[1].y * ni[0].x) / l_Ai_1Ai;
//        tp[0] = FSA.x - tan(CV_PI / 2 - Theta_fsa) * FSA.y;
//        tp[1] = FSA.y / sin(Theta_fsa);
//        tp[2] = FSA.x * FSA.x + FSA.y * FSA.y;
//        if (tp[0] > 0 && tp[1] > 0 && tp[2] > Length_fsa_inv * Length_fsa_inv && tp[2] < Length_fsa * Length_fsa)
//            return true;
//        else
//            return false;
//    }
//    bool CONSTRAINT_NEIBOR_TAIL(const Point AB[8]) const
//    {
//        int res = AB[5].x * AB[7].y - AB[5].y * AB[7].x;
//        if (res > 0)
//            return false;
//        res = AB[7].x * AB[0].y - AB[7].y * AB[0].x;
//        if (res > 0)
//            return false;
//        return true;
//    }
//    bool CONSTRAINT_GLOBAL_REGION(const Point vecFet[8], const Point *const *l1, const Point *checkPoint) const
//    {
//        Point checkVec;
//        int checkVal;
//        checkVec.x = checkPoint->x - l1[0]->x;
//        checkVec.y = checkPoint->y - l1[0]->y;
//        checkVal = -checkVec.x * vecFet[0].y + checkVec.y * vecFet[0].x;
//        if (checkVal > 0)
//            return false;
//        checkVal = checkVec.x * vecFet[2].y - checkVec.y * vecFet[2].x;
//        if (checkVal < 0)
//            return false;
//        checkVec.x = checkPoint->x - l1[3]->x;
//        checkVec.y = checkPoint->y - l1[3]->y;
//        checkVal = checkVec.x * vecFet[1].y - checkVec.y * vecFet[1].x;
//        if (checkVal < 0)
//            return false;
//        return true;
//    }
//    int CONSTRAINT_GLOABL_CURVATURE(const Point vecFet[8], const int flag) const
//    {
//        int val[3];
//        if (flag == 1)
//        {
//            val[1] = vecFet[1].x * vecFet[3].y - vecFet[1].y * vecFet[3].x;
//            if (val[1] > 0)
//                return -1;
//            val[2] = vecFet[3].x * vecFet[4].y - vecFet[3].y * vecFet[4].x;
//            if (val[2] > 0)
//                return -1;
//            val[0] = vecFet[1].x * vecFet[4].y - vecFet[1].y * vecFet[4].x;
//            if (abs(val[0]) < 1e-8)
//            {
//                val[0] = vecFet[1].x * vecFet[4].x + vecFet[1].y * vecFet[4].y;
//                if (val[0] > 0)
//                    return -1;
//                else
//                    return 0;
//            }
//            else
//            {
//                if (val[0] < 0)
//                    return 1;
//                else
//                {
//                    if (val[0] + val[1] < 0 && val[0] + val[2] < 0)
//                        return 0;
//                    else
//                        return -1;
//                }
//            }
//            return 0;
//        }
//        else
//        {
//            val[1] = vecFet[5].x * vecFet[7].y - vecFet[5].y * vecFet[7].x;
//            if (val[1] > 0)
//                return -1;
//            val[2] = vecFet[7].x * vecFet[0].y - vecFet[7].y * vecFet[0].x;
//            if (val[2] > 0)
//                return -1;
//            val[0] = vecFet[5].x * vecFet[0].y - vecFet[5].y * vecFet[0].x;
//            if (abs(val[0]) < 1e-8)
//            {
//                val[0] = vecFet[5].x * vecFet[0].x + vecFet[5].y * vecFet[0].y;
//                if (val[0] > 0)
//                    return -1;
//                else
//                    return 0;
//            }
//            else
//            {
//                if (val[0] < 0)
//                    return 1;
//                else
//                {
//                    if (val[0] + val[1] < 0 && val[0] + val[2] < 0)
//                        return 0;
//                    else
//                        return -1;
//                }
//            }
//            return 0;
//        }
//    }
//    int CONSTRAINT_GLOABL_CURVATURE(const Point arc_n[3]) const
//    {
//        int val[3];
//        val[1] = arc_n[0].x * arc_n[2].y - arc_n[0].y * arc_n[2].x;
//        if (val[1] > 0)
//            return -1;
//        val[2] = arc_n[2].x * arc_n[1].y - arc_n[2].y * arc_n[1].x;
//        if (val[2] > 0)
//            return -1;
//        val[0] = arc_n[0].x * arc_n[1].y - arc_n[0].y * arc_n[1].x;
//        if (abs(val[0]) < 1e-8)
//        {
//            val[0] = arc_n[0].x * arc_n[1].x + arc_n[0].y * arc_n[1].y;
//            if (val[0] > 0)
//                return -1;
//            else
//                return 0;
//        }
//        else
//        {
//            if (val[0] < 0)
//                return 1;
//            else
//            {
//                if (val[0] + val[1] < 0 && val[0] + val[2] < 0)
//                    return 0;
//                else
//                    return -1;
//            }
//        }
//        return 0;
//    }
//
//    bool RegionConstraint(const ArcSearchRegion *const asri, const ArcSearchRegion *const asrk) const
//    {
//        if (!(asri->isInSearchRegion(&asrk->A_1)))
//            return false;
//        if (!(asrk->isInSearchRegion(&asri->A__1)))
//            return false;
//        return true;
//    }
//    bool FSAConstraint(const ArcSearchRegion *const asri, const ArcSearchRegion *const asrk) const
//    {
//        const double theta_fsa = _theta_fsa, length_fsa = _length_fsa, length_fsa_inv = 1 / _length_fsa;
//
//        cv::Point2d vi, A0_ik, ni, n_i_1;
//        double lni2, t, p, lvi;
//        A0_ik.x = (asri->A__1.x + asrk->A_1.x) / 2.0, A0_ik.y = (asri->A__1.y + asrk->A_1.y) / 2.0;
//        ni.x = A0_ik.x - asri->A__2.x, ni.y = A0_ik.y - asri->A__2.y;
//        n_i_1.x = asrk->A_2.x - A0_ik.x, n_i_1.y = asrk->A_2.y - A0_ik.y;
//
//        lni2 = ni.x * ni.x + ni.y * ni.y;
//        vi.x = (ni.x * n_i_1.x + ni.y * n_i_1.y) / lni2;
//        vi.y = -(ni.x * n_i_1.y - ni.y * n_i_1.x) / lni2;
//        t = vi.x - tan(CV_PI / 2 - theta_fsa) * vi.y;
//        p = vi.y / sin(theta_fsa);
//        if (t <= 0 || p <= 0)
//            return false;
//        lvi = vi.x * vi.x + vi.y * vi.y;
//        if (lvi <= length_fsa_inv * length_fsa_inv || lvi >= length_fsa * length_fsa)
//            return false;
//        return true;
//    }
//    // l_ik >= T_ik && l_ki >= T_ki
//    char CASE_1(const ArcSearchRegion *const asri, const ArcSearchRegion *const asrk) const
//    {
//        if (!RegionConstraint(asri, asrk))
//            return -1;
//        if (!RegionConstraint(asrk, asri))
//            return -1;
//        return 1;
//    }
//    // l_ik >= T_ik && l_ki < T_ki
//    char CASE_2(const ArcSearchRegion *const asri, const ArcSearchRegion *const asrk) const
//    {
//        if (!RegionConstraint(asri, asrk))
//            return -1;
//        return 1;
//    }
//
//#ifdef DETAIL_BREAKDOWN
//    double t_preprocess, t_arcsegment, t_cluster, t_allgrouping, t_allfitting, t_allvalidation;
//    int fitting_time, valitation_time;
//
//    double ds_t_preprocess, ds_t_arcsegment, ds_t_cluster, ds_t_allgrouping, ds_t_allfitting, ds_t_allvalidation, dt_time;
//    int ds_fitting_time, ds_valitation_time, ds_num;
//#endif
//};
//
//typedef FLED AAMED;
//#ifndef TARGET_ZONE_DETECTOR_H
//#define TARGET_ZONE_DETECTOR_H
//
//class TargetZoneDetector
//{
//private:
//    AAMED detector;
//    std::map<std::string, std::vector<std::pair<cv::Point, int>>> target_zone_info;
//    int min_prep_frames;
//    int prep_frames_count;
//    int max_shift_frames;
//    int shift_frames_count;
//
//    std::vector<std::pair<cv::Point, int>> _detect(cv::Mat frame_gray);
//
//public:
//    TargetZoneDetector(int frame_width, int frame_height, int min_prep_frames = 10, int max_shift_frames = 5);
//    void prepare(cv::Mat frame, cv::Mat frame_gray);
//    int process(cv::Mat frame, cv::Mat frame_gray);
//    bool is_shifted();
//    bool is_ready();
//    std::map<std::string, std::vector<std::pair<cv::Point, int>>> get_target_zone_info()
//    {
//        return target_zone_info;
//    }
//};
//
//TargetZoneDetector::TargetZoneDetector(int frame_width, int frame_height, int min_prep_frames, int max_shift_frames)
//        : detector(frame_width + 1, frame_height + 1), min_prep_frames(min_prep_frames), prep_frames_count(0), max_shift_frames(max_shift_frames), shift_frames_count(0)
//{
//    detector.SetParameters(CV_PI / 3, 3.4, 0.77);
//}
//
////std::vector<std::pair<cv::Point, int>> TargetZoneDetector::_detect(cv::Mat frame_gray)
////{
////    detector.run_FLED(frame_gray);
////    int numDets = detector.getNumDets();
////
////    std::vector<std::pair<cv::Point, int>> circles;
////    if (numDets > 0)
////    {
////        float *data = new float[numDets * 6];
////        detector.UpdateResults(data);
////
////        for (int i = 0; i < numDets; i++)
////        {
////            int cy = data[i * 6 + 0];
////            int cx = data[i * 6 + 1];
////            int a = data[i * 6 + 2];
////            int b = data[i * 6 + 3];
////            int r = static_cast<int>((a + b) / 4);
////            if (r > 0) {
////                circles.push_back(std::make_pair(cv::Point(cx, cy), r));
////            }
////        }
////
////        if (!circles.empty())
////        {
////            std::sort(circles.begin(), circles.end(), [](const auto &a, const auto &b)
////            { return a.second > b.second; });
////
////            std::vector<std::pair<cv::Point, int>> filtered_circles;
////            auto largest_circle = circles[0];
////            int cx = largest_circle.first.x;
////            int cy = largest_circle.first.y;
////            filtered_circles.push_back(largest_circle);
////
////            for (size_t i = 1; i < circles.size(); ++i)
////            {
////                auto circle = circles[i];
////                int x = circle.first.x;
////                int y = circle.first.y;
////                double distance = cv::norm(cv::Point(x - cx, y - cy));
////                if (distance < 10)
////                    filtered_circles.push_back(circle);
////            }
////
////            return filtered_circles;
////        }
////    }
////    return circles;
////}
/////Time_tracking
////std::vector<std::pair<cv::Point, int>> TargetZoneDetector::_detect(cv::Mat frame_gray) {
////    auto start = std::chrono::high_resolution_clock::now();
////
////    detector.run_FLED(frame_gray);
////    int numDets = detector.getNumDets();
////
////    std::vector<std::pair<cv::Point, int>> circles;
////    if (numDets > 0) {
////        // Preallocate memory for detection data
////        std::vector<float> data(numDets * 6);
////        detector.UpdateResults(data.data());
////
////        for (int i = 0; i < numDets; i++) {
////            int cy = data[i * 6 + 0];
////            int cx = data[i * 6 + 1];
////            int a = data[i * 6 + 2];
////            int b = data[i * 6 + 3];
////            int r = static_cast<int>((a + b) / 4);
////
////            if (r > 0) {
////                circles.emplace_back(cv::Point(cx, cy), r);
////            }
////        }
////
////        if (!circles.empty()) {
////            // Sort by radius (largest to smallest)
////            std::sort(circles.begin(), circles.end(), [](const auto &a, const auto &b) {
////                return a.second > b.second;
////            });
////
////            // Filter based on proximity
////            std::vector<std::pair<cv::Point, int>> filtered_circles;
////            auto largest_circle = circles[0];
////            int cx = largest_circle.first.x;
////            int cy = largest_circle.first.y;
////            filtered_circles.push_back(largest_circle);
////
////            for (size_t i = 1; i < circles.size(); ++i) {
////                auto circle = circles[i];
////                int x = circle.first.x;
////                int y = circle.first.y;
////                double distance = cv::norm(cv::Point(x - cx, y - cy));
////
////                if (distance < 10) {  // Only keep circles close to the largest circle
////                    filtered_circles.push_back(circle);
////                }
////            }
////
////            // Limit to max_circles
////            const int max_circles = 5;
////            if (filtered_circles.size() > max_circles) {
////                filtered_circles.resize(max_circles);
////            }
////
////            auto end = std::chrono::high_resolution_clock::now();
////            auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count();
////            platform_log("Time taken for _detect: %lld ms\n", duration);
////
////            return filtered_circles;
////        }
////    }
////
////    auto end = std::chrono::high_resolution_clock::now();
////    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count();
////    platform_log("Time taken for _detect (no circles): %lld ms\n", duration);
////
////    return circles;
////}
////
////
////void TargetZoneDetector::prepare(cv::Mat frame, cv::Mat frame_gray)
////{
////    auto circles = _detect(frame_gray);
////    if (prep_frames_count < min_prep_frames)
////        prep_frames_count++;
////
////    target_zone_info["circles"] = circles;
////}
////int TargetZoneDetector::process(cv::Mat frame, cv::Mat frame_gray) {
////    auto start = std::chrono::high_resolution_clock::now();
////
////    auto circles = _detect(frame_gray);
////    if (circles.empty()) {
////        auto end = std::chrono::high_resolution_clock::now();
////        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count();
////        platform_log("Time taken for process (no circles): %lld ms\n", duration);
////        return 0;
////    }
////
////    auto current_circle = circles[0];
////    auto ori_circle = target_zone_info["circles"][0];
////    double distance = cv::norm(cv::Point(ori_circle.first.x - current_circle.first.x,
////                                         ori_circle.first.y - current_circle.first.y));
////
////    if (distance < 1.1) {
////        shift_frames_count = 0;
////
////        auto end = std::chrono::high_resolution_clock::now();
////        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count();
////        platform_log("Time taken for process (circle matched): %lld ms\n", duration);
////
////        return static_cast<int>(target_zone_info["circles"].size());
////    } else {
////        shift_frames_count++;
////        if (shift_frames_count >= max_shift_frames) {
////            for (size_t i = 0; i < circles.size(); i++) {
////                circles[i].second = target_zone_info["circles"][i].second;
////            }
////
////            target_zone_info["circles"] = circles;
////            shift_frames_count = 0;
////
////            auto end = std::chrono::high_resolution_clock::now();
////            auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count();
////            platform_log("Time taken for process (circles updated): %lld ms\n", duration);
////
////            return static_cast<int>(circles.size());
////        } else {
////            auto end = std::chrono::high_resolution_clock::now();
////            auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count();
////            platform_log("Time taken for process (shift frames incremented): %lld ms\n", duration);
////
////            return 0;
////        }
////    }
////}
//
//
//
//
//
//
/////test
////std::vector<std::pair<cv::Point, int>> TargetZoneDetector::_detect(cv::Mat frame_gray) {
////    auto start = std::chrono::high_resolution_clock::now();
////
////    detector.run_FLED(frame_gray);
////    int numDets = detector.getNumDets();
////
////    std::vector<std::pair<cv::Point, int>> circles;
////    if (numDets > 0) {
////        // Preallocate memory for detection data
////        std::vector<float> data(numDets * 6);
////        detector.UpdateResults(data.data());
////
////        // Debug: Log number of detections
////        platform_log("Number of detections: %d\n", numDets);
////
////        // Process detections without filtering
////        for (int i = 0; i < numDets; i++) {
////            int cy = static_cast<int>(data[i * 6 + 0]);
////            int cx = static_cast<int>(data[i * 6 + 1]);
////            int a = static_cast<int>(data[i * 6 + 2]);
////            int b = static_cast<int>(data[i * 6 + 3]);
////            int r = static_cast<int>((a + b) / 4);
////
////            if (r > 0) {
////                circles.emplace_back(cv::Point(cx, cy), r);
////
////                // Debug: Log circle details
////                platform_log("Detected circle: cx=%d, cy=%d, r=%d\n", cx, cy, r);
////            }
////        }
////
////        // Sort by radius (largest to smallest)
////        std::sort(circles.begin(), circles.end(), [](const auto &a, const auto &b) {
////            return a.second > b.second;
////        });
////
////        // Limit to a maximum number of circles
////        const int max_circles = 5;
////        if (circles.size() > max_circles) {
////            circles.resize(max_circles);
////        }
////
////        auto end = std::chrono::high_resolution_clock::now();
////        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count();
////        platform_log("Time taken for _detect: %lld ms\n", duration);
////
////        return circles;
////    }
////
////    auto end = std::chrono::high_resolution_clock::now();
////    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count();
////    platform_log("Time taken for _detect (no circles): %lld ms\n", duration);
////
////    return circles;
////}
/////currently_working
//std::vector<std::pair<cv::Point, int>> TargetZoneDetector::_detect(cv::Mat frame_gray) {
//    detector.run_FLED(frame_gray);
//    int numDets = detector.getNumDets();
//    std::vector<std::pair<cv::Point, int>> circles;
//    if (numDets > 0) {
//        float* data = new float[numDets * 6];
//        detector.UpdateResults(data);
//        for (int i = 0; i < numDets; i++) {
//            int cy = data[i * 6 + 0];
//            int cx = data[i * 6 + 1];
//            int a = data[i * 6 + 2];
//            int b = data[i * 6 + 3];
//            int r = static_cast<int>((a + b) / 4);
//            circles.push_back(std::make_pair(cv::Point(cx, cy), r));
//        }
//        delete[] data;
//        if (!circles.empty()) {
//            std::sort(circles.begin(), circles.end(), [](const auto &a, const auto &b) {
//                return a.second > b.second;
//            });
//            std::vector<std::pair<cv::Point, int>> filtered_circles;
//            auto largest_circle = circles[0];
//            int cx = largest_circle.first.x;
//            int cy = largest_circle.first.y;
//            filtered_circles.push_back(largest_circle);
//            for (size_t i = 1; i < circles.size(); ++i) {
//                auto circle = circles[i];
//                int x = circle.first.x;
//                int y = circle.first.y;
//                double distance = cv::norm(cv::Point(x - cx, y - cy));
//                if (distance < 10)
//                    filtered_circles.push_back(circle);
//            }
//            return filtered_circles;
//        }
//    }
//    return circles;
//}
//
//void TargetZoneDetector::prepare(cv::Mat frame, cv::Mat frame_gray) {
//    auto circles = _detect(frame_gray);
//    if (prep_frames_count < min_prep_frames)
//        prep_frames_count++;
//
//    target_zone_info["circles"] = circles;
//}
//
//int TargetZoneDetector::process(cv::Mat frame, cv::Mat frame_gray) {
//    auto circles = _detect(frame_gray);
//    if (circles.empty())
//        return 0;
//    if (!target_zone_info["circles"].empty()) {
//        auto current_circle = circles[0];
//        auto ori_circle = target_zone_info["circles"][0];
//        double distance = cv::norm(cv::Point(ori_circle.first.x - current_circle.first.x,
//                                             ori_circle.first.y - current_circle.first.y));
//        if (distance < 1.1) {
//            shift_frames_count = 0;
//            return target_zone_info["circles"].size();
//        } else {
//            shift_frames_count++;
//            if (shift_frames_count >= max_shift_frames) {
//                for (size_t i = 0; i < circles.size(); i++) {
//                    circles[i].second = target_zone_info["circles"][i].second;
//                }
//                target_zone_info["circles"] = circles;
//                shift_frames_count = 0;
//                return circles.size();
//            }
//        }
//    }
//    return 0;
//}
/////testing_
////int TargetZoneDetector::process(cv::Mat frame, cv::Mat frame_gray) {
////    auto start = std::chrono::high_resolution_clock::now();
////
////    auto circles = _detect(frame_gray);
////    if (circles.empty()) {
////        auto end = std::chrono::high_resolution_clock::now();
////        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count();
////        platform_log("Time taken for process (no circles): %lld ms\n", duration);
////        return 0;
////    }
////
////    platform_log("Processing %zu circles\n", circles.size());
////
////    // Ensure target_zone_info["circles"] exists and is not empty
////    if (target_zone_info.find("circles") == target_zone_info.end() || target_zone_info["circles"].empty()) {
////        platform_log("No valid circles in target_zone_info. Updating with new circles.\n");
////        target_zone_info["circles"] = circles;
////        shift_frames_count = 0; // Reset shift frame count
////        return static_cast<int>(circles.size());
////    }
////
////    auto current_circle = circles[0];
////    auto ori_circle = target_zone_info["circles"][0];
////    double dx = ori_circle.first.x - current_circle.first.x;
////    double dy = ori_circle.first.y - current_circle.first.y;
////    double distance = sqrt(dx * dx + dy * dy);
////
////    if (distance < 1.1) {
////        shift_frames_count = 0;
////
////        auto end = std::chrono::high_resolution_clock::now();
////        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count();
////        platform_log("Time taken for process (circle matched): %lld ms\n", duration);
////
////        return static_cast<int>(target_zone_info["circles"].size());
////    } else {
////        shift_frames_count++;
////        platform_log("Shift frame count incremented to: %d\n", shift_frames_count);
////
////        if (shift_frames_count >= max_shift_frames) {
////            for (size_t i = 0; i < circles.size(); i++) {
////                if (i < target_zone_info["circles"].size()) {
////                    circles[i].second = target_zone_info["circles"][i].second;
////                }
////            }
////
////            target_zone_info["circles"] = circles;
////            shift_frames_count = 0;
////
////            auto end = std::chrono::high_resolution_clock::now();
////            auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count();
////            platform_log("Time taken for process (circles updated): %lld ms\n", duration);
////
////            return static_cast<int>(circles.size());
////        } else {
////            auto end = std::chrono::high_resolution_clock::now();
////            auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count();
////            platform_log("Time taken for process (shift frames incremented): %lld ms\n", duration);
////
////            return 0;
////        }
////    }
////}
//
//
//
/////Old_one
////int TargetZoneDetector::process(cv::Mat frame, cv::Mat frame_gray)
////{
////    auto circles = _detect(frame_gray);
////    if (circles.empty())
////        return 0;
////
////    auto current_circle = circles[0];
////    auto ori_circle = target_zone_info["circles"][0];
////    double distance = cv::norm(cv::Point(ori_circle.first.x - current_circle.first.x, ori_circle.first.y - current_circle.first.y));
////
////    if (distance < 1.1)
////    {
////        shift_frames_count = 0;
////        return target_zone_info["circles"].size();
////    }
////    else
////    {
////        shift_frames_count++;
////        if (shift_frames_count >= max_shift_frames)
////        {
////            for (size_t i = 0; i < circles.size(); i++)
////            {
////                circles[i].second = target_zone_info["circles"][i].second;
////            }
////
////            target_zone_info["circles"] = circles;
////            shift_frames_count = 0;
////            return circles.size();
////        }
////        else
////        {
////            return 0;
////        }
////    }
////}
//
//
//
//bool TargetZoneDetector::is_shifted()
//{
//    return shift_frames_count > 0;
//}
//
//bool TargetZoneDetector::is_ready()
//{
//    return prep_frames_count >= min_prep_frames;
//}
//
//#endif // TARGET_ZONE_DETECTOR_H
//
//static inline double Get_del_phi_max(double s, double phi)
//{
//    const int num_del_phi = 8;
//    const double cos_phi = cos(phi), sin_phi = sin(phi);
//    const double s_pow_2 = pow(s, 2), s_pow_3 = pow(s, 3);
//
//    double A[num_del_phi], B[num_del_phi];
//    double lst_del_phi[num_del_phi], del_phi, max_del_phi(-1);
//
//    A[0] = fabs(sin_phi + cos_phi), A[1] = fabs(sin_phi - cos_phi);
//    A[2] = A[4] = A[6] = A[0], A[3] = A[5] = A[7] = A[1];
//
//    B[0] = B[1] = cos_phi + sin_phi;
//    B[2] = B[3] = -cos_phi + sin_phi;
//    B[4] = B[5] = cos_phi - sin_phi;
//    B[6] = B[7] = -cos_phi - sin_phi;
//
//    for (int n = 0; n < num_del_phi; n++)
//    {
//        del_phi = A[n] * (s_pow_2 - s * B[n] + pow(B[n], 2));
//        // del_phi = A[n] * (s_pow_2 + B[n] * (B[n] - s));
//        // del_phi = A[n] * (pow(B[n] - s, 2) - s * B[n]);
//        if (del_phi > max_del_phi)
//            max_del_phi = del_phi;
//    }
//
//    return max_del_phi / s_pow_2;
//}
//
//static bool getValidpMax(vector<Point> &pts, int P1, int Pn, int &pMax)
//{
//    pMax = 0;
//
//    Point *_data = pts.data();
//    Point n1, n2;
//    int d, dMax(-1);
//    double phi, s, dTol;
//    // Get Max Deviation and index: dMax, pMax
//    n1.x = _data[Pn].x - _data[P1].x, n1.y = _data[Pn].y - _data[P1].y;
//
//    for (int idx = P1; idx < Pn; idx++)
//    {
//        n2.x = _data[idx].x - _data[P1].x;
//        n2.y = _data[idx].y - _data[P1].y;
//        d = abs(n1.x * n2.y - n1.y * n2.x);
//
//        if (d >= dMax)
//            dMax = d, pMax = idx;
//    }
//    if (pMax == 0)
//        return false;
//
//    s = sqrt(double(n1.x * n1.x + n1.y * n1.y));
//    if (n1.x == 0 || n1.y == 0)
//        dTol = 1;
//    else
//    {
//        phi = atan(double(n1.x) / double(n1.y));
//        dTol = Get_del_phi_max(s, phi);
//    }
//
//    if (dMax > dTol * s && pMax != 0)
//        return true;
//    else
//        return false;
//}
//
//static void LRDP_Max(vector<Point> &pts, int P1, int Pn, vector<int> &DominantPointsIdx)
//{
//    double dMax(0), d(0), dTol(0), phi(0), s(0), m(0);
//    const double eps = 1e-8;
//    int pMax(0);
//
//    bool isValid = getValidpMax(pts, P1, Pn, pMax);
//    if (isValid)
//    {
//        DominantPointsIdx.push_back(pMax);
//        LRDP_Max(pts, P1, pMax, DominantPointsIdx);
//        LRDP_Max(pts, pMax, Pn, DominantPointsIdx);
//    }
//}
//
//void adaptApproxPolyDP(std::vector<cv::Point> &pts, std::vector<cv::Point> &DominantPoints)
//{
//    DominantPoints.clear();
//    int P1 = 0, Pn = pts.size() - 1;
//
//    vector<int> DominantPointsIdx;
//
//    if (pts.size() < 3)
//    {
//        DominantPoints = pts;
//        return;
//    }
//
//    DominantPointsIdx.push_back(P1);
//    DominantPointsIdx.push_back(Pn);
//    while (pts[P1] == pts[Pn])
//        Pn -= 1;
//
//    LRDP_Max(pts, P1, Pn, DominantPointsIdx);
//
//    // deduplicate and sort Dominant Points indices
//    DominantPointsIdx.erase(unique(DominantPointsIdx.begin(), DominantPointsIdx.end()), DominantPointsIdx.end());
//
//    sort(DominantPointsIdx.begin(), DominantPointsIdx.end(), std::less<int>()); // Éý
//
//    // generate list of dominant points
//    for (int i = 0; i < DominantPointsIdx.size(); i++)
//        DominantPoints.push_back(pts[DominantPointsIdx[i]]);
//}
//
//// void adaptApproximateContours(const std::vector<cv::Point> &pts, std::vector<cv::Point> &approx);
//// void adaptApproxPolyDP(std::vector<cv::Point> &pts, std::vector<cv::Point> &approx); // ���һ��������
//
//// RotatedRect: ���ĵ㣬�����ᣬ��ת��(�Ƕ�)
//double EllipseOverlap(cv::RotatedRect &ellipse1, cv::RotatedRect &ellipse2);
//
//void EllipseNonMaximumSuppression(std::vector<cv::RotatedRect> &detElps, std::vector<double> &detEllipseScore, double T_iou);
//
//FLED::FLED(int drows, int dcols)
//{
//
//    _T_dp = sqrt(2.0);
//    _T_gradnum = 5;
//
//    vld_use_time = 0;
//
//    dROWS = drows;
//    dCOLS = dcols;
//    data = new Node_FC[dROWS * dCOLS];
//    for (int i = 0; i < dROWS; i++)
//        for (int j = 0; j < dCOLS; j++)
//            data[dIDX(i, j)] = Node_FC(i, j, PIXEL_SCALE);
//
//    dls_C = Mat::zeros(6, 6, CV_64FC1);
//    // dls_C.at<double>(0, 2) = 0.5;
//    // dls_C.at<double>(1, 1) = -1;
//    // dls_C.at<double>(2, 0) = 0.5;
//    dls_C.at<double>(2, 2) = 1;
//
//    double h = CV_PI * 2 / VALIDATION_NUMBER;
//    for (int i = 0; i < VALIDATION_NUMBER; i++)
//    {
//        vldBaseData[i][0] = cos(i * h);
//        vldBaseData[i][1] = sin(i * h);
//        vldBaseDataX[i] = cos(i * h);
//        vldBaseDataY[i] = sin(i * h);
//    }
//
//    LinkMatrix.Update(800 * 800);
//    lA.resize(800);
//
//    visited.Update(800);
//    fitComb_LR.Update(512);
//    asrs.reserve(800);
//    ArcFitMat.reserve(512);
//    ///////Pre-Reserver////////////////////////
//    query_arcs.resize(2);
//    // oneContour.reserve(1000);
//    // oneContourOpp.reserve(1000);
//    // candidateLines.reserve(1000);
//    // detEllipse.reserve(300);
//#ifdef DETAIL_BREAKDOWN
//    fitting_time = valitation_time = 0;
//    t_allfitting = t_allvalidation = 0;
//
//    dt_time = ds_t_preprocess = ds_t_arcsegment = ds_t_cluster = ds_t_allgrouping = ds_t_allfitting = ds_t_allvalidation = 0;
//    ds_fitting_time = ds_valitation_time = ds_num = 0;
//
//#endif
//}
//
//void FLED::initFrame()
//{
//    edgeContours.clear();
//    dpContours.clear();
//    FSA_ArcContours.clear();
//
//    detEllipses.clear();
//    detEllipseScore.clear();
//
//    StrongArcs.clear();
//    WeakArcs.clear();
//}
//void FLED::release()
//{
//    if (data != NULL)
//        delete[] data;
//
//    LinkMatrix.release();
//    visited.release();
//    //	lA.release();
//}
//bool FLED::checkInputImage(int rows, int cols)
//{
//    if (rows > dROWS || cols > dCOLS)
//        return false;
//    else
//        return true;
//}
//void FLED::run_AAMED_WithoutCanny(Mat Img_G)
//{
//
//    // Pre-Processing
//#ifdef DETAIL_BREAKDOWN
//    double tmp_st;
//    tmp_st = cv::getTickCount();
//#endif
//
//    double t1, t2;
//
//    sum_time = 0;
//    fitnum = 0;
//    case_stat[0] = case_stat[1] = case_stat[2] = case_stat[3] = 0;
//    // isBIDIR = 0;
//
//    initFrame();
//
//    // t1 = cv::getTickCount();
//    iROWS = Img_G.rows;
//    iCOLS = Img_G.cols;
//
//    imgCanny = Img_G.clone();
//
//    // t1 = cv::getTickCount();
//    uchar *_imgCanny = (uchar *)imgCanny.data;
//    // ��Ե�������ң�����С��T_edge_num(��������Ӧ)���ᱻ�ӵ�
//    findContours(_imgCanny);
//
//    BoldEdge(_imgCanny, edgeContours); // ��ͼ����мӴ֣�������ұ�Ե��
//#ifdef DETAIL_BREAKDOWN
//    t_preprocess = (cv::getTickCount() - tmp_st) * 1000 / cv::getTickFrequency();
//
//    tmp_st = cv::getTickCount();
//#endif
//
//    // Arc Segmentation
//    const int edgeContoursNum = int(edgeContours.size());
//    for (int i = 0; i < edgeContoursNum; i++)
//    {
//#if ADAPT_APPROX_CONTOURS
//        // adaptApproximateContours(edgeContours[i], oneContour);
//        adaptApproxPolyDP(edgeContours[i], oneContour);
//#else
//        approxPolyDP(edgeContours[i], oneContour, _T_dp, false);
//#endif
//        if (oneContour.size() < MIN_DP_CONTOUR_NUM)
//            continue;
//        dpContours.push_back(oneContour);
//    }
//    // t2 = cv::getTickCount();
//    // cout << "RDP using time:" << (t2 - t1) * 1000 / cv::getTickFrequency() << endl;
//
//    // drawDPContours();
//
//    const int dpContoursNum = int(dpContours.size());
//    for (int i = 0; i < dpContoursNum; i++)
//    {
//        FSA_Segment(dpContours[i]);
//    }
//
//#ifdef DETAIL_BREAKDOWN
//    t_arcsegment = (cv::getTickCount() - tmp_st) * 1000 / cv::getTickFrequency();
//    tmp_st = cv::getTickCount();
//#endif
//
//    SortArcs(FSA_ArcContours); // ��Ի��θ�����������
//
//    CreateArcSearchRegion(FSA_ArcContours); // �������л��ε���������
//
//    int fsa_Arcs = int(FSA_ArcContours.size());
//    if (fsa_Arcs == 0)
//        return;
//    getArcs_KDTrees(FSA_ArcContours);
//
//    Arcs_Grouping(FSA_ArcContours);
//
//    // writeLinkMatrix();
//    // t2 = cv::getTickCount();
//    // sum_time += (t2 - t1) * 1000 / cv::getTickFrequency();
//
//    const char *_linkMatrix = LinkMatrix.GetDataPoint();
//    getlinkArcs(_linkMatrix, fsa_Arcs);
//
//    // drawFSA_ArcContours();
//    // cv::waitKey(1);
//
//    visited.Update(fsa_Arcs);
//    searched.Update(fsa_Arcs);
//
//    GetArcMat(ArcFitMat, FSA_ArcContours); // ����ÿ�����ε���Ͼ���
//
//    _arc_grouped_label.clear();
//    _arc_grouped_label.resize(fsa_Arcs, 0);
//
//    for (int root_idx = 0; root_idx < fsa_Arcs; root_idx++)
//    {
//        if (FSA_ArcContours[root_idx].size() <= 3)
//            continue;
//
//        if (_arc_grouped_label[root_idx] != 0)
//            continue;
//        // t1 = cv::getTickCount();
//        search_group[0].clear(), search_group[1].clear();     // �����һ�����ݵ�
//        search_arcMats[0].clear(), search_arcMats[1].clear(); // �����һ�����������ݵ�
//        searched.clean();
//
//        temp.push_back(root_idx); // ������ڵ㻡��
//        *visited[root_idx] = 1;   // ��ǰ�ڵ���ʹ�
//        memcpy(fitArcTemp.val, ArcFitMat[root_idx].val, sizeof(double) * MAT_NUMBER);
//
//        // t1 = cv::getTickCount();
//        PosteriorArcsSearch2(root_idx);
//        // t2 = (double)cv::getTickCount();
//
//        temp.push_back(root_idx);
//        *visited[root_idx] = 1;
//        AnteriorArcsSearch(root_idx);
//
//        // t1 = cv::getTickCount();
//        sortCombine(fitComb_LR, search_arcMats, search_group);
//        // t2 = (double)cv::getTickCount();
//        // printf("The %dth root arc: the search_group size is %d, %d\n", root_idx, search_group[0].size(), search_group[1].size());
//        // t1 = cv::getTickCount();
//        BiDirectionVerification(fitComb_LR, search_arcMats, search_group, _arc_grouped_label);
//        // t2 = (double)cv::getTickCount();
//        // sum_time += (t2 - t1) * 1000 / cv::getTickFrequency();
//    }
//
//#ifdef DETAIL_BREAKDOWN
//    t_allgrouping = (cv::getTickCount() - tmp_st) * 1000 / cv::getTickFrequency();
//    tmp_st = cv::getTickCount();
//#endif
//
//#if SELECT_CLUSTER_METHOD == OUR_CLUSTER_METHOD
//    EllipseNonMaximumSuppression(detEllipses, detEllipseScore, 0.7);
//#elif SELECT_CLUSTER_METHOD == PRASAD_CLUSTER_METHOD
//    ClusterEllipses(detEllipses, detEllipseScore);
//#endif
//    asrs.clear();
//
//#ifdef DETAIL_BREAKDOWN
//    t_cluster = (cv::getTickCount() - tmp_st) * 1000 / cv::getTickFrequency();
//#endif
//}
//void FLED::run_FLED(Mat Img_G)
//{
//    // Pre-Processing
//#ifdef DETAIL_BREAKDOWN
//    double tmp_st;
//    t_allfitting = t_allvalidation = 0;
//    fitting_time = valitation_time = 0;
//    tmp_st = cv::getTickCount();
//#endif
//
//    // vld_use_time = 0;
//    double t1, t2;
//    sum_time = 0;
//    fitnum = 0;
//    case_stat[0] = case_stat[1] = case_stat[2] = case_stat[3] = 0;
//    // isBIDIR = 0;
//
//    initFrame();
//
//    iROWS = Img_G.rows;
//    iCOLS = Img_G.cols;
//
//    // ---------------- opencv�汾Canny-----------
//    // ͼ��ģ������ֵ��Ҫ����Ӧ�����Ӧ����ͼ�������й�
//
//    const double var = 0.6 / 0.8, sprec = 3;
//    int L = int(var * sqrt(2 * sprec * log(10.0))) + 1;
//    GaussianBlur(Img_G, Img_G, cv::Size(2 * L + 1, 2 * L + 1), var);
//    // cv::medianBlur(Img_G, Img_G, 3);
//
//    // Canny����������������Ӧ
//    int low, high;
//    calCannyThreshold(Img_G, low, high);
//    Canny(Img_G, imgCanny, low, high);
//
//    // t1 = cv::getTickCount();
//    uchar *_imgCanny = (uchar *)imgCanny.data;
//    // ��Ե�������ң�����С��T_edge_num(��������Ӧ)���ᱻ�ӵ�
//    findContours(_imgCanny);
//
//    BoldEdge(_imgCanny, edgeContours); // ��ͼ����мӴ֣�������ұ�Ե��
//
//#ifdef DETAIL_BREAKDOWN
//    t_preprocess = (cv::getTickCount() - tmp_st) * 1000 / cv::getTickFrequency();
//
//    tmp_st = cv::getTickCount();
//#endif
//
//    // t1 = cv::getTickCount();
//    const int edgeContoursNum = int(edgeContours.size());
//    for (int i = 0; i < edgeContoursNum; i++)
//    {
//#if ADAPT_APPROX_CONTOURS
//        // adaptApproximateContours(edgeContours[i], oneContour);
//        adaptApproxPolyDP(edgeContours[i], oneContour);
//#else
//        approxPolyDP(edgeContours[i], oneContour, _T_dp, false);
//#endif
//        if (oneContour.size() < MIN_DP_CONTOUR_NUM)
//            continue;
//        dpContours.push_back(oneContour);
//    }
//    // t2 = cv::getTickCount();
//    // cout << "RDP using time:" << (t2 - t1) * 1000 / cv::getTickFrequency() << endl;
//
//    // drawDPContours();
//
//    const int dpContoursNum = int(dpContours.size());
//    for (int i = 0; i < dpContoursNum; i++)
//    {
//        FSA_Segment(dpContours[i]);
//    }
//
//#ifdef DETAIL_BREAKDOWN
//    t_arcsegment = (cv::getTickCount() - tmp_st) * 1000 / cv::getTickFrequency();
//    tmp_st = cv::getTickCount();
//#endif
//
//    SortArcs(FSA_ArcContours); // ��Ի��θ�����������
//
//    CreateArcSearchRegion(FSA_ArcContours); // �������л��ε���������
//
//    int fsa_Arcs = int(FSA_ArcContours.size());
//    if (fsa_Arcs == 0)
//        return;
//    getArcs_KDTrees(FSA_ArcContours);
//
//    Arcs_Grouping(FSA_ArcContours);
//
//    // writeLinkMatrix();
//    // t2 = cv::getTickCount();
//    // sum_time += (t2 - t1) * 1000 / cv::getTickFrequency();
//
//    const char *_linkMatrix = LinkMatrix.GetDataPoint();
//    getlinkArcs(_linkMatrix, fsa_Arcs);
//
//    // drawFSA_ArcContours();
//    // cv::waitKey(1);
//
//    visited.Update(fsa_Arcs);
//    searched.Update(fsa_Arcs);
//
//    GetArcMat(ArcFitMat, FSA_ArcContours); // ����ÿ�����ε���Ͼ���
//
//    _arc_grouped_label.clear();
//    _arc_grouped_label.resize(fsa_Arcs, 0);
//
//    for (int root_idx = 0; root_idx < fsa_Arcs; root_idx++)
//    {
//        if (FSA_ArcContours[root_idx].size() <= 3)
//            continue;
//
//        if (_arc_grouped_label[root_idx] != 0)
//            continue;
//        // t1 = cv::getTickCount();
//        search_group[0].clear(), search_group[1].clear();     // �����һ�����ݵ�
//        search_arcMats[0].clear(), search_arcMats[1].clear(); // �����һ�����������ݵ�
//        searched.clean();
//
//        temp.push_back(root_idx); // ������ڵ㻡��
//        *visited[root_idx] = 1;   // ��ǰ�ڵ���ʹ�
//        memcpy(fitArcTemp.val, ArcFitMat[root_idx].val, sizeof(double) * MAT_NUMBER);
//
//        // t1 = cv::getTickCount();
//        PosteriorArcsSearch2(root_idx);
//        // t2 = (double)cv::getTickCount();
//
//        temp.push_back(root_idx);
//        *visited[root_idx] = 1;
//        AnteriorArcsSearch(root_idx);
//
//        // t1 = cv::getTickCount();
//        sortCombine(fitComb_LR, search_arcMats, search_group);
//        // t2 = (double)cv::getTickCount();
//        // printf("The %dth root arc: the search_group size is %d, %d\n", root_idx, search_group[0].size(), search_group[1].size());
//        // t1 = cv::getTickCount();
//        BiDirectionVerification(fitComb_LR, search_arcMats, search_group, _arc_grouped_label);
//        // t2 = (double)cv::getTickCount();
//        // sum_time += (t2 - t1) * 1000 / cv::getTickFrequency();
//    }
//
//#ifdef DETAIL_BREAKDOWN
//    t_allgrouping = (cv::getTickCount() - tmp_st) * 1000 / cv::getTickFrequency();
//    tmp_st = cv::getTickCount();
//#endif
//
//#if SELECT_CLUSTER_METHOD == OUR_CLUSTER_METHOD
//    EllipseNonMaximumSuppression(detEllipses, detEllipseScore, 0.7);
//#elif SELECT_CLUSTER_METHOD == PRASAD_CLUSTER_METHOD
//    ClusterEllipses(detEllipses, detEllipseScore);
//#endif
//    asrs.clear();
//    // cout << vld_use_time << endl;
//
//#ifdef DETAIL_BREAKDOWN
//    t_cluster = (cv::getTickCount() - tmp_st) * 1000 / cv::getTickFrequency();
//#endif
//}
//
//// void FLED::writeDetailData()
//// {
////     std::ofstream outfile("DetailAAMED.aamed", std::ios::binary);
//
////     // basic information
////     outfile << "basic";
////     outfile.write((char*)&iROWS, sizeof(int));
////     outfile.write((char*)&iCOLS, sizeof(int));
////     outfile << "endbasic.";
//
////     //write edgecontours;
////     outfile << "edgecontours";
////     int edgeNum = (int)edgeContours.size();
////     outfile.write((char*)&edgeNum, sizeof(int));
////     int edgeiNum;
////     Point dotTemp;
////     for (int i = 0; i < edgeNum; i++)
////     {
////         edgeiNum = (int)edgeContours[i].size();
////         outfile.write((char*)&edgeiNum, sizeof(int));
////         for (int j = 0; j < edgeiNum; j++)
////         {
////             dotTemp = edgeContours[i][j];
////             outfile.write((char*)&(dotTemp.x), sizeof(int));
////             outfile.write((char*)&(dotTemp.y), sizeof(int));
////         }
////     }
////     outfile << "endedgecontours.";
//
////     //write DP contours;
////     outfile << "dpcontours";
////     int dpNum = (int)dpContours.size();
////     outfile.write((char*)&dpNum, sizeof(int));
////     int dpiNum;
////     for (int i = 0; i < dpNum; i++)
////     {
////         dpiNum = (int)dpContours[i].size();
////         outfile.write((char*)&dpiNum, sizeof(int));
////         for (int j = 0; j < dpiNum; j++)
////         {
////             dotTemp = dpContours[i][j];
////             outfile.write((char*)&(dotTemp.x), sizeof(int));
////             outfile.write((char*)&(dotTemp.y), sizeof(int));
////         }
////     }
////     outfile << "enddpcontours.";
//
////     //write arccontours
////     outfile << "arccontours";
////     int fsaNum = (int)FSA_ArcContours.size();
////     outfile.write((char*)&fsaNum, sizeof(int));
////     int fsaiNum;
////     for (int i = 0; i < fsaNum; i++)
////     {
////         fsaiNum = (int)FSA_ArcContours[i].size();
////         outfile.write((char*)&fsaiNum, sizeof(int));
////         for (int j = 0; j < fsaiNum; j++)
////         {
////             dotTemp = FSA_ArcContours[i][j];
////             outfile.write((char*)&(dotTemp.x), sizeof(int));
////             outfile.write((char*)&(dotTemp.y), sizeof(int));
////         }
////     }
////     outfile << "endarccontours.";
//
////     // write linkmatrix.
////     outfile << "arcadjacencymatrix";
////     outfile.write((char*)&fsaNum, sizeof(int));
////     char* _LinkMatrix = LinkMatrix.GetDataPoint();
////     outfile.write(_LinkMatrix, sizeof(char)*fsaNum*fsaNum);
////     outfile << "endarcadjacencymatrix.";
//
////     // write final results;
////     outfile << "detectedellipses";
////     int elpNUm = detEllipses.size();
////     outfile.write((char*)&elpNUm, sizeof(int));
////     for (int i = 0; i < detEllipses.size(); i++)
////     {
////         outfile.write((char*)&detEllipses[i].center.x, sizeof(float));
////         outfile.write((char*)&detEllipses[i].center.y, sizeof(float));
////         outfile.write((char*)&detEllipses[i].size.height, sizeof(float));
////         outfile.write((char*)&detEllipses[i].size.width, sizeof(float));
////         outfile.write((char*)&detEllipses[i].angle, sizeof(float));
////     }
////     outfile << "enddetectedellipses.";
//
////     outfile.close();
//// }
//
//// void FLED::writeFLED(string filepath, string filename, double useTime)
//// {
////     std::ofstream outfile(filepath + filename, std::ios::out);
////     outfile << useTime << endl;
////     for (int i = 0; i < detEllipses.size(); i++)
////     {
////         outfile << "1" << " ";
////         outfile << detEllipses[i].center.x << " " << detEllipses[i].center.y << " ";
////         outfile << detEllipses[i].size.height << " " << detEllipses[i].size.width << " " << detEllipses[i].angle << endl;
////     }
////     outfile.close();
//// }
//
//void FLED::showDetailBreakdown(cv::Vec<double, 10> &detDetailTime, int needDisplay)
//{
//#ifdef DETAIL_BREAKDOWN
//    detDetailTime[0] = t_preprocess;
//    detDetailTime[1] = t_arcsegment;
//    detDetailTime[2] = t_allgrouping - t_allfitting - t_allvalidation;
//
//    detDetailTime[3] = t_allfitting;
//    detDetailTime[4] = fitting_time;
//    detDetailTime[5] = fitting_time > 0 ? t_allfitting / fitting_time : 0;
//
//    detDetailTime[6] = t_allvalidation;
//    detDetailTime[7] = valitation_time;
//    detDetailTime[8] = valitation_time > 0 ? t_allvalidation / valitation_time : 0;
//
//    detDetailTime[9] = t_cluster;
//
//    double sum_time = detDetailTime[0] + detDetailTime[1] + detDetailTime[2] + detDetailTime[3] + detDetailTime[6] + detDetailTime[9];
//    dt_time += sum_time;
//
//    if (needDisplay)
//    {
//        printf("Pre-Processing: %.4f ms.\n", detDetailTime[0]);
//        printf("Arc Segmentation: %.4f ms.\n", detDetailTime[1]);
//        printf("Arc Grouping: %.4f ms.\n", detDetailTime[2]);
//        printf("Ellipse Fitting: %.4f ms, %.2f times, %.4f ms/time\n", detDetailTime[3], detDetailTime[4], detDetailTime[5]);
//        printf("Ellipse Validation: %.4f ms, %.2f times, %.4f ms/time\n", detDetailTime[6], detDetailTime[7], detDetailTime[8]);
//        printf("Ellipse Cluster: %.4f ms.\n", detDetailTime[9]);
//
//        printf("Total: %.4f ms.\n", sum_time);
//    }
//
//    ds_t_preprocess += detDetailTime[0];
//    ds_t_arcsegment += detDetailTime[1];
//    ds_t_allgrouping += detDetailTime[2];
//
//    ds_t_allfitting += detDetailTime[3];
//    ds_fitting_time += detDetailTime[4];
//
//    ds_t_allvalidation += detDetailTime[6];
//    ds_valitation_time += detDetailTime[7];
//
//    ds_t_cluster += detDetailTime[9];
//
//    ds_num++;
//
//#endif
//}
//
//void FLED::showDatasetBreakdown()
//{
//#ifdef DETAIL_BREAKDOWN
//    printf("Average Pre-Processing: %.4f ms.\n", ds_t_preprocess / ds_num);
//    printf("Average Arc Segmentation: %.4f ms.\n", ds_t_arcsegment / ds_num);
//    printf("Average Arc Grouping: %.4f ms.\n", ds_t_allgrouping / ds_num);
//
//    double tmp;
//
//    tmp = ds_fitting_time > 0 ? ds_t_allfitting / ds_fitting_time : 0;
//    printf("Average Ellipse Fitting: %.4f ms, %.2f times, %.4f ms/time\n", ds_t_allfitting / ds_num, double(ds_fitting_time) / ds_num, tmp);
//
//    tmp = ds_valitation_time > 0 ? ds_t_allvalidation / ds_valitation_time : 0;
//    printf("Average Ellipse Validation: %.4f ms, %.2f times, %.4f ms/time\n", ds_t_allvalidation / ds_num, double(ds_valitation_time) / ds_num, tmp);
//
//    printf("Average Ellipse Cluster: %.4f ms.\n", ds_t_cluster / ds_num);
//
//    double sum_time = dt_time / ds_num;
//    printf("Average Time: %.4f ms.\n", sum_time);
//#endif
//}
//
//void FLED::getArcs_KDTrees(vector<vector<Point>> &arcs)
//{
//    source_arcs.create(arcs.size(), 2, CV_32FC1);
//    Point *temp;
//    float *_source_arcs = (float *)source_arcs.data;
//    int source_num = arcs.size();
//    for (int i = 0; i < source_num; i++)
//    {
//        temp = &arcs[i][0];
//        _source_arcs[i << 1] = temp->x;
//        _source_arcs[(i << 1) + 1] = temp->y;
//    }
//    kdTree_Arcs.build(source_arcs, indexParams, cvflann::FLANN_DIST_L1);
//}
//
//static double get_T_edge_num(double T_dp, double theta_fsa, double &_T_min_minor)
//{
//    _T_min_minor = T_dp / (1 - cos(theta_fsa / 2));
//
//    double min_edge = _T_min_minor * theta_fsa;
//
//    return min_edge;
//}
//
//static double get_T_edge_num(double theta_fsa, double &_T_min_minor)
//{
//    _T_min_minor = 1 / (1 - cos(theta_fsa / 2));
//
//    return _T_min_minor * 2 * theta_fsa;
//}
//
//void FLED::SetParameters(double theta_fsa, double length_fsa, double T_val)
//{
//    assert(theta_fsa >= 0 || theta_fsa <= CV_PI / 2);
//    assert(length_fsa > 1);
//    assert(T_val > 0);
//
//    _theta_fsa = theta_fsa;
//    _length_fsa = length_fsa;
//    _T_val = T_val;
//
//    _T_edge_num = get_T_edge_num(theta_fsa, _T_min_minor);
//}
//
//void FLED::SetParameters(double T_dp, double theta_fsa, double length_fsa, double T_val, int grad_num)
//{
//    assert(T_dp >= std::sqrt(2.0) / 2);
//    assert(theta_fsa >= 0 || theta_fsa <= CV_PI / 2);
//    assert(length_fsa > 1);
//
//    _T_dp = T_dp;
//    _theta_fsa = theta_fsa;
//    _length_fsa = length_fsa;
//    _T_val = T_val;
//    _T_gradnum = grad_num;
//
//    _T_edge_num = get_T_edge_num(T_dp, theta_fsa, _T_min_minor);
//}
//
//void FLED::findContours(uchar *_edge)
//{
//    const int clockWise[8][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}, {-1, 1}, {1, 1}, {1, -1}, {-1, -1}};
//    const int anticlockWise[8][2] = {{0, -1}, {1, 0}, {0, 1}, {-1, 0}, {-1, -1}, {1, -1}, {1, 1}, {-1, 1}};
//    int idx_first = (iROWS - 1) * iCOLS;
//
//    for (int i = 0; i < iCOLS; i++)
//    {
//        _edge[i] = 0;
//        _edge[idx_first + i] = 0;
//    }
//    for (int i = 1; i < iROWS - 1; i++)
//    {
//        _edge[i * iCOLS] = 0;
//        _edge[i * iCOLS + iCOLS - 1] = 0;
//    }
//    for (int i = 1; i < iROWS; i++)
//    {
//        idx_first = i * iCOLS;
//        for (int j = 1; j < iCOLS; j++)
//        {
//            if (_edge[idx_first + j])
//            {
//                _edge[idx_first + j] = 0;
//                if (_edge[idx_first + iCOLS + j - 1] && _edge[idx_first + iCOLS + j] && _edge[idx_first + iCOLS + j + 1])
//                    continue;
//                else
//                {
//                    findContour(clockWise, anticlockWise, _edge, i, j);
//                }
//            }
//        }
//    }
//}
//
//void FLED::BoldEdge(uchar *_edge, const vector<vector<Point>> &edge_Contours)
//{
//    const uchar matBold[9] = {1, 2, 3, 11, 12, 13, 21, 22, 23};
//    // const uchar matBold[9] = { 12,12,12,12,12,12,12,12,12 };
//    int numContours = int(edge_Contours.size());
//    int x, y, idx, idx_i;
//    for (int i = 0; i < numContours; i++)
//    {
//        idx_i = int(edge_Contours[i].size());
//        for (int j = 0; j < idx_i; j++)
//        {
//            idx = edge_Contours[i][j].x * iCOLS + edge_Contours[i][j].y;
//            for (int k = 0; k < 9; k++)
//            {
//                x = matBold[k] / 10;
//                y = matBold[k] - 10 * x;
//                x -= 1, y -= 2;
//                _edge[idx + x * iCOLS + y] = matBold[k];
//            }
//        }
//    }
//}
//
//void FLED::findContour(const int Wise[8][2], const int antiWise[8][2], uchar *Edge, int x, int y)
//{
//    bool isEnd;
//    int find_x, find_y;
//    int move_x = x, move_y = y;
//    oneContour.clear();
//    oneContourOpp.clear();
//    oneContour.push_back(Point(x, y));
//    int idxdMove = dIDX(x, y), idxiMove = iIDX(x, y), idxdFind, idxiFind;
//    data[idxdMove].setFirst();
//    while (1)
//    {
//        isEnd = true;
//        idxiMove = iIDX(move_x, move_y);
//        for (int i = 0; i < 8; i++)
//        {
//            find_x = move_x + Wise[i][0];
//            find_y = move_y + Wise[i][1];
//            idxiFind = iIDX(find_x, find_y);
//            if (Edge[idxiFind])
//            {
//                Edge[idxiFind] = 0;
//                isEnd = false;
//                idxdMove = dIDX(move_x, move_y);
//                idxdFind = dIDX(find_x, find_y);
//                (data + idxdMove)->nextIs(data + idxdFind);
//                move_x = find_x;
//                move_y = find_y;
//                oneContour.push_back(Point(move_x, move_y));
//                break;
//            }
//        }
//        if (isEnd)
//        {
//            idxdMove = dIDX(move_x, move_y);
//            (data + idxdMove)->nextIs(NULL);
//            break;
//        }
//    }
//    move_x = oneContour[0].x;
//    move_y = oneContour[0].y;
//    while (1)
//    {
//        isEnd = true;
//        idxiMove = iIDX(move_x, move_y);
//        for (int i = 0; i < 8; i++)
//        {
//            find_x = move_x + antiWise[i][0];
//            find_y = move_y + antiWise[i][1];
//            idxiFind = iIDX(find_x, find_y);
//            if (Edge[idxiFind])
//            {
//                Edge[idxiFind] = 0;
//                isEnd = false;
//                idxdMove = dIDX(move_x, move_y);
//                idxdFind = dIDX(find_x, find_y);
//                (data + idxdMove)->lastIs(data + idxdFind);
//                move_x = find_x;
//                move_y = find_y;
//                oneContourOpp.push_back(Point(move_x, move_y));
//                break;
//            }
//        }
//        if (isEnd)
//        {
//            idxdMove = dIDX(move_x, move_y);
//            (data + idxdMove)->lastIs(NULL);
//            break;
//        }
//    }
//    if (oneContour.size() + oneContourOpp.size() > _T_edge_num)
//    {
//        if (oneContourOpp.size() > 0)
//        {
//            Point temp;
//            for (int i = 0; i < (oneContourOpp.size() + 1) / 2; i++)
//            {
//                temp = oneContourOpp[i];
//                oneContourOpp[i] = oneContourOpp[oneContourOpp.size() - 1 - i];
//                oneContourOpp[oneContourOpp.size() - 1 - i] = temp;
//            }
//            oneContourOpp.insert(oneContourOpp.end(), oneContour.begin(), oneContour.end());
//            edgeContours.push_back(oneContourOpp);
//        }
//        else
//            edgeContours.push_back(oneContour);
//    }
//}
//
//void FLED::FSA_Segment(vector<Point> &dpContour)
//{
//
//    const double Theta_fsa = _theta_fsa, Length_fsa = _length_fsa, Length_fsa_inv = 1 / _length_fsa;
//
//    cv::Vec4i temp_line;
//    Point Ai[3], ni[2];
//    cv::Point2f FSA;
//    float tp[3], l_Ai_1Ai;
//    int dir;
//    const int dpContourNum = dpContour.size();
//    const double Length_fsa2 = Length_fsa * Length_fsa, Length_fsa_inv2 = Length_fsa_inv * Length_fsa_inv;
//
//    for (int i = 1; i < dpContourNum; i++)
//    {
//        oneContour.clear();
//        Ai[0] = dpContour[i - 1];
//        Ai[1] = dpContour[i];
//        ni[0] = Ai[1] - Ai[0];
//        l_Ai_1Ai = ni[0].x * ni[0].x + ni[0].y * ni[0].y;
//        if (l_Ai_1Ai < 5)
//            continue;
//        if (i + 1 >= dpContour.size())
//        {
//            continue;
//        }
//        Ai[2] = dpContour[i + 1];
//        ni[1] = Ai[2] - Ai[1];
//        dir = ni[0].x * ni[1].y - ni[0].y * ni[1].x;
//        FSA.x = (ni[0].x * ni[1].x + ni[0].y * ni[1].y) / l_Ai_1Ai;
//        FSA.y = abs(dir) / l_Ai_1Ai;
//        tp[0] = FSA.x - tan(CV_PI / 2 - Theta_fsa) * FSA.y;
//        tp[1] = FSA.y / sin(Theta_fsa);
//        tp[2] = FSA.x * FSA.x + FSA.y * FSA.y;
//        if (tp[0] <= 0 || tp[1] <= 0 || tp[2] < Length_fsa_inv2 || tp[2] > Length_fsa2)
//        {
//            continue;
//        }
//        dir = dir > 0 ? 1 : -1;
//        i++;
//        oneContour.push_back(Ai[0]), oneContour.push_back(Ai[1]), oneContour.push_back(Ai[2]);
//        for (int j = i + 1; j < dpContour.size(); j++, i = j - 1)
//        {
//            ni[0] = ni[1];
//            l_Ai_1Ai = ni[0].x * ni[0].x + ni[0].y * ni[0].y;
//            ni[1] = dpContour[j] - dpContour[j - 1];
//            FSA.x = (ni[0].x * ni[1].x + ni[0].y * ni[1].y) / l_Ai_1Ai;
//            FSA.y = dir * (ni[0].x * ni[1].y - ni[0].y * ni[1].x) / l_Ai_1Ai;
//            tp[0] = FSA.x - tan(CV_PI / 2 - Theta_fsa) * FSA.y;
//            tp[1] = FSA.y / sin(Theta_fsa);
//            tp[2] = FSA.x * FSA.x + FSA.y * FSA.y;
//            if (tp[0] > 0 && tp[1] > 0 && tp[2] > Length_fsa_inv2 && tp[2] < Length_fsa2)
//            {
//                oneContour.push_back(dpContour[j]);
//                continue;
//            }
//            else
//                break;
//        }
//        if (oneContour.size() < MIN_DP_CONTOUR_NUM)
//            continue;
//        if (dir > 0)
//            clockwiseContour(oneContour);
//
//        Point st, ed;
//        st = oneContour[0], ed = oneContour.back();
//        int arc_edge_num = data[dIDX(ed.x, ed.y)].edgeID - data[dIDX(st.x, st.y)].edgeID;
//        if (arc_edge_num < _T_edge_num / 2 * oneContour.size())
//            continue;
//        FSA_ArcContours.push_back(oneContour);
//    }
//}
//
//void FLED::clockwiseContour(vector<Point> &antiContour)
//{
//    Point dot_ed;
//    dot_ed = antiContour[antiContour.size() - 1];
//    int idxdHead = dIDX(antiContour[0].x, antiContour[0].y);
//    int idxdTail = dIDX(dot_ed.x, dot_ed.y);
//    if (data[idxdHead].lastAddress != NULL) // 如果非空，则选择起点为下一点
//    {
//        antiContour[0] = data[idxdHead].nextAddress->Location; // 选择起点为下一点
//        data[idxdHead].nextAddress->lastAddress = NULL;
//        data[idxdHead].nextAddress = NULL;
//        idxdHead = dIDX(antiContour[0].x, antiContour[0].y);
//    }
//    if (data[idxdTail].nextAddress != NULL) // 如果不为空，则选择起点为前一点
//    {
//        dot_ed = data[idxdTail].lastAddress->Location;
//        antiContour[antiContour.size() - 1] = dot_ed;
//        data[idxdTail].lastAddress->nextAddress = NULL;
//        data[idxdTail].lastAddress = NULL;
//        idxdTail = dIDX(dot_ed.x, dot_ed.y);
//    }
//    // 至此，起点和终点均已预处理完毕，只需要对整个弧段进行交换处理即可
//    Node_FC *SigPot_Temp = NULL;
//    Point *Idx_Dot = NULL;
//    for (int step_idx = idxdTail; step_idx != idxdHead;)
//    {
//        SigPot_Temp = data[step_idx].nextAddress;
//        data[step_idx].nextAddress = data[step_idx].lastAddress;
//        data[step_idx].lastAddress = SigPot_Temp;
//        Idx_Dot = &(data[step_idx].nextAddress->Location);
//        step_idx = Idx_Dot->x * dCOLS + Idx_Dot->y;
//    } // 最后一个点没有交换
//    data[idxdHead].lastAddress = data[idxdHead].nextAddress;
//    data[idxdHead].nextAddress = NULL;
//    // 后面参与计算均与起点终点有关，基本不会再涉及到内部矩阵元素，因此交换首尾重要信息
//    int ID_temp = data[idxdTail].edgeID;
//    double fit_sig_temp;
//    data[idxdTail].edgeID = data[idxdHead].edgeID;
//    data[idxdHead].edgeID = ID_temp;
//    for (uint mm = 0; mm < MAT_NUMBER; mm++)
//    {
//        fit_sig_temp = data[idxdTail].nodesMat[mm];
//        data[idxdTail].nodesMat[mm] = data[idxdHead].nodesMat[mm];
//        data[idxdHead].nodesMat[mm] = fit_sig_temp;
//    }
//    for (uint mm = 0; mm < antiContour.size() / 2; mm++)
//    {
//        dot_ed = antiContour[mm];
//        antiContour[mm] = antiContour[antiContour.size() - 1 - mm];
//        antiContour[antiContour.size() - 1 - mm] = dot_ed;
//    }
//}
//
//void FLED::GetArcMat(vector<cv::Vec<double, MAT_NUMBER>> &arcfitmat, vector<vector<Point>> &fsa_arc)
//{
//    const int arcs_num = fsa_arc.size();
//    cv::Vec<double, MAT_NUMBER> *_arcs_data = NULL, *arc_temp = NULL;
//    Point *st, *ed;
//    int idx_st, idx_ed;
//    Node_FC *st_node = NULL, *ed_node = NULL;
//
//    arcfitmat.resize(arcs_num);
//    _arcs_data = arcfitmat.data();
//
//    for (int i = 0; i < arcs_num; i++)
//    {
//        arc_temp = _arcs_data + i;
//        st = &fsa_arc[i][0];
//        ed = &fsa_arc[i].back();
//        idx_st = dIDX(st->x, st->y);
//        idx_ed = dIDX(ed->x, ed->y);
//        st_node = data + idx_st;
//        ed_node = data + idx_ed;
//        for (int j = 0; j < MAT_NUMBER; j++)
//            arc_temp->val[j] = ed_node->nodesMat[j] - st_node->nodesMat[j];
//    }
//}
//
//void FLED::init_fitmat(double *basic_fitmat, double *init_fitmat, int num)
//{
//    for (int i = 0; i < num; i++)
//        basic_fitmat[i] = init_fitmat[i];
//}
//
//void FLED::push_fitmat(double *basic_fitmat, double *add_fitmat, int num)
//{
//    for (int i = 0; i < num; i++)
//        basic_fitmat[i] += add_fitmat[i];
//}
//
//void FLED::pop_fitmat(double *basic_fitmat, double *minus_fitmat, int num)
//{
//    for (int i = 0; i < num; i++)
//        basic_fitmat[i] -= minus_fitmat[i];
//}
//
//void FLED::sortCombine(GPSD &fitComb, vector<cv::Vec<double, MAT_NUMBER>> arcMats[2], vector<vector<int>> s_group[2])
//{
//    double t1, t2;
//
//    int temp_pos = 0; // 统计负数个数
//
//    int linking_num = arcMats[0].size(), linked_num = arcMats[1].size(), idx_i, idx;
//    double val_l, val_r;
//    fitComb.Update(linking_num * linked_num + linking_num + linked_num);
//    for (int i = 0; i < linking_num; i++) // r
//    {
//        val_r = arcMats[0][i][MAT_NUMBER - 1];
//        idx_i = i * linked_num;
//        for (int j = 0; j < linked_num; j++)
//        {
//            if (s_group[1][j].size() >= 2)
//            {
//                val_l = arcMats[1][j][MAT_NUMBER - 1];
//                fitComb[idx_i + j]->idx_r = i;
//                fitComb[idx_i + j]->idx_l = j;
//                fitComb[idx_i + j]->val = val_l + val_r;
//            }
//            else
//            {
//                fitComb[idx_i + j]->val = -1;
//                temp_pos++;
//            }
//        }
//    }
//    idx_i = linking_num * linked_num;
//    int arc_dp_idx;
//    for (int i = 0; i < linking_num; i++)
//    {
//        idx = idx_i + i;
//        // if (s_group[0][i].size() == 1) //说明这个只有1个fsa段
//        //{
//        //	if (FSA_ArcContours[s_group[0][i][0]].size() < MIN_DP_CONTOUR_NUM)
//        //	{
//        //		fitComb[idx]->val = -1;
//        //		fitComb[idx]->idx_r = i;
//        //		fitComb[idx]->idx_l = -1;
//        //		continue;
//        //	}
//        // }
//
//        fitComb[idx]->val = arcMats[0][i][MAT_NUMBER - 1];
//        fitComb[idx]->idx_r = i;
//        fitComb[idx]->idx_l = -1;
//    }
//    idx_i = linking_num * linked_num + linking_num;
//    for (int i = 0; i < linked_num; i++)
//    {
//        idx = idx_i + i;
//        if (s_group[1][i].size() > 2)
//        {
//            fitComb[idx]->val = arcMats[1][i][MAT_NUMBER - 1];
//            fitComb[idx]->idx_l = i;
//            fitComb[idx]->idx_r = -1;
//        }
//            // else if (s_group[1][i].size() == 2)
//            //{
//            //	if (FSA_ArcContours[s_group[1][i][1]].size() < MIN_DP_CONTOUR_NUM)
//            //	{
//            //		fitComb[idx]->val = -1;
//            //		fitComb[idx]->idx_r = i;
//            //		fitComb[idx]->idx_l = -1;
//            //		continue;
//            //	}
//            // }
//        else
//        {
//            fitComb[idx]->val = -1;
//            temp_pos++;
//        }
//    }
//    // t2 = (double)cv::getTickCount();
//    // sum_time += (t2 - t1) * 1000 / cv::getTickFrequency();
//    // t1 = cv::getTickCount();
//    // cout << linking_num*linked_num + linking_num + linked_num << ". 复数个数：" << temp_pos << endl;
//    //	t1 = cv::getTickCount();
//    std::sort(fitComb[0], fitComb[linking_num * linked_num + linking_num + linked_num - 1], cmp);
//    //	t2 = (double)cv::getTickCount();
//    //	sum_time += (t2 - t1) * 1000 / cv::getTickFrequency();
//}
//
//void FLED::SegmentAnArc(vector<Point> &dpContour)
//{
//    const double Theta_fsa = _theta_fsa, Length_fsa = _length_fsa, Length_fsa_inv = 1 / _length_fsa;
//    const int StrongPointNum = 4;
//
//    cv::Vec4i temp_line;
//    Point Ai[3], ni[2];
//    cv::Point2f FSA;
//    float tp[3], l_Ai_1Ai;
//    int dir;
//    const int dpContourNum = dpContour.size();
//    const double Length_fsa2 = Length_fsa * Length_fsa, Length_fsa_inv2 = Length_fsa_inv * Length_fsa_inv;
//
//    vector<vector<Point>> tmpAllSegmentArcs;
//    vector<int> tmpArcsDir;
//    for (int i = 1; i < dpContourNum; i++)
//    {
//        oneContour.clear();
//        Ai[0] = dpContour[i - 1];
//        Ai[1] = dpContour[i];
//        oneContour.push_back(Ai[0]), oneContour.push_back(Ai[1]);
//
//        ni[0] = Ai[1] - Ai[0];
//        l_Ai_1Ai = ni[0].x * ni[0].x + ni[0].y * ni[0].y;
//        if (i + 1 >= dpContour.size())
//        {
//            tmpAllSegmentArcs.push_back(oneContour), tmpArcsDir.push_back(0);
//            continue;
//        }
//
//        Ai[2] = dpContour[i + 1];
//        ni[1] = Ai[2] - Ai[1];
//        dir = ni[0].x * ni[1].y - ni[0].y * ni[1].x;
//        FSA.x = (ni[0].x * ni[1].x + ni[0].y * ni[1].y) / l_Ai_1Ai;
//        FSA.y = abs(dir) / l_Ai_1Ai;
//        tp[0] = FSA.x - tan(CV_PI / 2 - Theta_fsa) * FSA.y;
//        tp[1] = FSA.y / sin(Theta_fsa);
//        tp[2] = FSA.x * FSA.x + FSA.y * FSA.y;
//
//        if (tp[0] <= 0 || tp[1] <= 0 || tp[2] < Length_fsa_inv2 || tp[2] > Length_fsa2)
//        {
//            tmpAllSegmentArcs.push_back(oneContour), tmpArcsDir.push_back(0);
//            continue;
//        }
//
//        dir = dir > 0 ? 1 : -1;
//        i++;
//        oneContour.push_back(Ai[2]);
//        for (int j = i + 1; j < dpContour.size(); j++, i = j - 1)
//        {
//            ni[0] = ni[1];
//            l_Ai_1Ai = ni[0].x * ni[0].x + ni[0].y * ni[0].y;
//            ni[1] = dpContour[j] - dpContour[j - 1];
//            FSA.x = (ni[0].x * ni[1].x + ni[0].y * ni[1].y) / l_Ai_1Ai;
//            FSA.y = dir * (ni[0].x * ni[1].y - ni[0].y * ni[1].x) / l_Ai_1Ai;
//            tp[0] = FSA.x - tan(CV_PI / 2 - Theta_fsa) * FSA.y;
//            tp[1] = FSA.y / sin(Theta_fsa);
//            tp[2] = FSA.x * FSA.x + FSA.y * FSA.y;
//            if (tp[0] > 0 && tp[1] > 0 && tp[2] > Length_fsa_inv2 && tp[2] < Length_fsa2)
//            {
//                oneContour.push_back(dpContour[j]);
//                continue;
//            }
//            else
//                break;
//        }
//        tmpAllSegmentArcs.push_back(oneContour), tmpArcsDir.push_back(dir);
//    }
//}
//
//void FLED::SortArcs(vector<vector<Point>> &detArcs)
//{
//    int arc_num = detArcs.size();
//    vector<int> arcs_edge_num(arc_num);
//    Point st, ed;
//    for (int i = 0; i < arc_num; i++)
//    {
//        st = detArcs[i][0];
//        ed = detArcs[i].back();
//        arcs_edge_num[i] = data[dIDX(ed.x, ed.y)].edgeID - data[dIDX(st.x, st.y)].edgeID;
//    }
//
//    Node_FC *_tmpdata = data;
//    int tmpdCols = dCOLS;
//    sort(detArcs.begin(), detArcs.end(),
//         [&_tmpdata, &tmpdCols](vector<Point> &a1, vector<Point> &a2)
//         {
//             Point st, ed;
//             st = a1[0], ed = a1.back();
//             int arc1_edge_num = _tmpdata[ed.x * tmpdCols + ed.y].edgeID - _tmpdata[st.x * tmpdCols + st.y].edgeID;
//
//             st = a2[0], ed = a2.back();
//             int arc2_edge_num = _tmpdata[ed.x * tmpdCols + ed.y].edgeID - _tmpdata[st.x * tmpdCols + st.y].edgeID;
//
//             return arc1_edge_num > arc2_edge_num;
//         });
//
//    // for (int i = 0; i < arc_num; i++)
//    //{
//    //	if(arcs_edge_num[i] < _T_edge_num)
//    //		detArcs[i].clear();
//    // }
//}
//
//void FLED::Arcs_Grouping(vector<vector<Point>> &fsaarcs)
//{
//
//    // cv::flann::KDTreeIndexParams indexParamst;
//    // cv::flann::Index kdTree_Arcst;
//    // kdTree_Arcst.build(source_arcs, indexParamst, cvflann::FLANN_DIST_L1);
//    // Mat indices_arcst, dist_arcst;
//
//    int fsaarcs_num = fsaarcs.size();
//    int sub_arcnum, dist_l, searchNum, findIdx, linkval[2], group_res, _linkIdx;
//    // const int maxArcs = std::min(32, fsaarcs_num);
//    const int maxArcs = fsaarcs_num; // std::min(32, fsaarcs_num);
//    int *_indices_arcs = NULL;
//    float *_dist_arcs = NULL;
//    Point *l1[4] = {NULL, NULL, NULL, NULL}, *l2[4] = {NULL, NULL, NULL, NULL};
//
//    Point l1_l2_O, vecl[2], l1_l2[3], arc_n[3];
//
//    unsigned char distType = 0x00;
//    Point vecFeature[8];
//
//    LinkMatrix.Update(fsaarcs_num * fsaarcs_num); // �����ڽӾ������
//    char *_LinkMatrix = LinkMatrix.GetDataPoint();
//
//    int T_ij, T_ji;
//    Point *_vec_data_i = NULL, *_vec_data_j = NULL; // ��ȡvector������ָ��
//
//    // 1-25 Add
//    ArcSearchRegion asr1, asr2;
//    ArcSearchRegion *_asrs = asrs.data(), *_asr1(NULL), *_asr2(NULL);
//
//    for (int i = 0; i < fsaarcs_num; i++)
//    {
//        sub_arcnum = int(fsaarcs[i].size());
//        _vec_data_i = fsaarcs[i].data();
//
//        l1[0] = _vec_data_i;                  // A^{i}_1
//        l1[1] = _vec_data_i + 1;              // A^{i}_2
//        l1[2] = _vec_data_i + sub_arcnum - 2; // A^{i}_{-2}
//        l1[3] = _vec_data_i + sub_arcnum - 1; // A^{i}_{-1}
//
//        // asr1.create(l1[0], l1[1], l1[2], l1[3]); // Create Search Region, Modification of Prasad
//        _asr1 = _asrs + i;
//        vecFeature[0].x = l1[1]->x - l1[0]->x;
//        vecFeature[0].y = l1[1]->y - l1[0]->y; // A0��A1
//        vecFeature[1].x = l1[3]->x - l1[2]->x;
//        vecFeature[1].y = l1[3]->y - l1[2]->y; // Aend-1Aend
//        vecFeature[2].x = l1[3]->x - l1[0]->x;
//        vecFeature[2].y = l1[3]->y - l1[0]->y;
//
//        dist_l = abs(l1[0]->x - l1[3]->x) + abs(l1[0]->y - l1[3]->y); // KD-Tree Search Radius.
//        query_arcs[0] = l1[3]->x;
//        query_arcs[1] = l1[3]->y; // KD-Tree Search root.
//        // ����kd���������������Լ���ĵ�
//        searchNum = kdTree_Arcs.radiusSearch(query_arcs, indices_arcs, dist_arcs, dist_l, maxArcs);
//        // if (i == 0)
//        //{
//        //	cout << "Begin Error" << endl;
//        //	cout << query_arcs[0] << "," << query_arcs[1] << endl;
//        //	cout << indices_arcs << endl;
//        //	cout << dist_arcs << endl;
//        //	cout << dist_l << endl;
//        //	cout << maxArcs << endl;
//
//        //	float *_source_arcs = (float*)source_arcs.data;
//        //	if (source_arcs.rows > 13)
//        //	{
//        //		cout << _source_arcs[13 * 2] << " , " << _source_arcs[13 * 2 + 1] << endl;
//        //		//system("pause");
//        //	}
//        //	//kdTree_Arcst.radiusSearch(query_arcs, indices_arcst, dist_arcst, dist_l, maxArcs);
//        //	//cout << "New KDTree" << endl;
//        //	//cout << indices_arcst << endl;
//        //	//cout << dist_arcst << endl;
//        //
//        //}
//
//        _indices_arcs = (int *)indices_arcs.data;
//        _dist_arcs = (float *)dist_arcs.data;
//
//        for (int j = 0; j < searchNum; j++)
//        {
//            distType = FLED_GROUPING_IBmA1_IAnB1;
//            findIdx = _indices_arcs[j];           // �ҵ��Ļ��α��
//            _linkIdx = i * fsaarcs_num + findIdx; // ��ȡ�ڽӾ���ı��
//            if (_LinkMatrix[_linkIdx] != 0)
//                continue;
//            int findArcNum = fsaarcs[findIdx].size();
//            _vec_data_j = fsaarcs[findIdx].data(); // ��ȡ�������Ļ���ָ��
//
//            l2[0] = _vec_data_j;                  // A^{j}_1
//            l2[1] = _vec_data_j + 1;              // A^{j}_2
//            l2[2] = _vec_data_j + findArcNum - 2; // A^{j}_{-2}
//            l2[3] = _vec_data_j + findArcNum - 1; // A^{j}_{-1}
//
//            // asr2.create(l2[0], l2[1], l2[2], l2[3]); // Create Search Region, Modification of Prasad
//            _asr2 = _asrs + findIdx;
//            vecFeature[3].x = l2[0]->x - l1[3]->x;
//            vecFeature[3].y = l2[0]->y - l1[3]->y;
//            vecFeature[7].x = l1[0]->x - l2[3]->x;
//            vecFeature[7].y = l1[0]->y - l2[3]->y;
//
//            T_ij = std::min(abs(vecFeature[1].x) + abs(vecFeature[1].y),          // |A^{i}_{-1} - A^{i}_{-2}|
//                            abs(l2[0]->x - l2[1]->x) + abs(l2[0]->y - l2[1]->y)); // |A^{k}_1 - A^{k}_2|
//            T_ji = std::min(abs(vecFeature[0].x) + abs(vecFeature[0].x),          // |A^{i}_1 - A^{i}_2|
//                            abs(l2[2]->x - l2[3]->x) + abs(l2[2]->y - l2[3]->y)); // |A^{k}_{-1} - A^{k}_{-2}|
//            if (_dist_arcs[j] < T_ij)
//                distType = distType | FLED_GROUPING_CAnB1;
//            if (abs(vecFeature[7].x) + abs(vecFeature[7].y) < T_ji)
//                distType = distType | FLED_GROUPING_CBmA1;
//
//            switch (distType)
//            {
//                case FLED_GROUPING_FBmA1_FAnB1: // ��������β����ȶ���Զ
//                {
//                    // group_res = CASE_1(&asr1, &asr2);
//                    group_res = CASE_1(_asr1, _asr2);
//                    // case_stat[0]++;
//                    // group_res = Group4FAnB1_FBmA1(vecFeature, l1, l2);
//                    // group_res = Group4FAnB1_FBmA1(vecFeature, l1, l2, &asr1, &asr2);
//                    break;
//                }
//                case FLED_GROUPING_FBmA1_CAnB1: // ������Ͻ���β���Զ
//                {
//                    group_res = Group4CAnB1_FBmA1(vecFeature, l1, l2);
//                    // case_stat[1]++;
//                    break;
//                }
//                case FLED_GROUPING_CBmA1_FAnB1: // �������Զ��β��Ͻ�
//                {
//                    group_res = Group4FAnB1_CBmA1(vecFeature, l1, l2);
//                    // case_stat[2]++;
//                    break;
//                }
//                case FLED_GROUPING_CBmA1_CAnB1: // ��������β����ȶ��Ͻ�
//                {
//                    if (findIdx == i)
//                    {
//                        group_res = 1;
//                        for (int j = 0; j < fsaarcs_num; j++)
//                        {
//                            _LinkMatrix[i * fsaarcs_num + j] = _LinkMatrix[j * fsaarcs_num + i] = -1;
//                        }
//                    }
//                    else
//                        group_res = Group4CAnB1_CBmA1(vecFeature, l1, l2);
//
//                    // case_stat[3]++;
//
//                    break;
//                }
//                default:
//                    break;
//            }
//            // if (i == 25 && findIdx == 32)
//            //	cout << group_res << endl;
//            // if (i == 32 && findIdx == 25)
//            //	cout << group_res << endl;
//            if (findIdx == i && group_res == -1) // ������i���ܸ��Լ���������������β����ܸ����������
//            {
//                continue;
//            }
//
//            _LinkMatrix[_linkIdx] = group_res;
//            if (group_res == -1)
//                _LinkMatrix[findIdx * fsaarcs_num + i] = -1;
//            // if (findIdx == i&&group_res==-1) //������i���ܸ��Լ���������������β����ܸ����������
//            //{
//            //	for (int j = 0; j < fsaarcs_num; j++)
//            //	{
//            //		_LinkMatrix[i*fsaarcs_num + j] = _LinkMatrix[j*fsaarcs_num + i] = -1;
//            //	}
//            // }
//        }
//    }
//}
//
//void FLED::getlinkArcs(const char *_linkMatrix, int arc_num)
//{
//    lA.resize(arc_num);
//    // ���ҵ�i�����������Ļ��κͲ�������
//    for (int i = 0; i < arc_num; i++)
//    {
//        // if (i == 25)
//        //	cout << "Begin Error" << endl;
//        int idx = i * arc_num;
//        lA[i].clear();
//        for (int j = 0; j < arc_num; j++)
//        {
//            // if (i == 32)
//            //	cout << "Begin ERROR" << endl;
//            // if (i == 25 && j == 32)
//            //	cout << int(_linkMatrix[idx + j]) << endl;
//            if (_linkMatrix[idx + j] == 1) // i ��j������������
//                lA[i].idx_linking.push_back(j);
//            else if (_linkMatrix[idx + j] == -1) // i��j����������
//                lA[i].idx_notlink.push_back(j);
//            if (_linkMatrix[j * arc_num + i] == 1)
//                lA[i].idx_linked.push_back(j);
//        }
//    }
//}
//
//bool FLED::FittingConstraint(double *_linkingMat, double *_linkedMat, cv::RotatedRect &fitres)
//{
//#ifdef DETAIL_BREAKDOWN
//    double tmp_st;
//#endif
//    double fitingMat[MAT_NUMBER];
//    if (_linkingMat != NULL && _linkedMat != NULL)
//    {
//        for (int i = 0; i < MAT_NUMBER; i++)
//            fitingMat[i] = _linkingMat[i] + _linkedMat[i];
//    }
//    else if (_linkingMat != NULL)
//    {
//        for (int i = 0; i < MAT_NUMBER; i++)
//            fitingMat[i] = _linkingMat[i];
//    }
//    else if (_linkedMat != NULL)
//    {
//        for (int i = 0; i < MAT_NUMBER; i++)
//            fitingMat[i] = _linkedMat[i];
//    }
//
//    double ellipse_error;
//    // return false;
//    // double t1, t2;
//    // t1 = cv::getTickCount();
//    // ElliFit(fitingMat, ellipse_error, fitres);
//#ifdef DETAIL_BREAKDOWN
//    tmp_st = cv::getTickCount();
//#endif
//    fitEllipse(fitingMat, ellipse_error, fitres);
//#ifdef DETAIL_BREAKDOWN
//    t_allfitting += (cv::getTickCount() - tmp_st) * 1000 / cv::getTickFrequency();
//    fitting_time++;
//#endif
//    // t2 = (double)cv::getTickCount();
//    // vld_use_time += (t2 - t1) * 1000 / cv::getTickFrequency();
//    // fitnum++;
//    // sum_time += (t2 - t1) * 1000 / cv::getTickFrequency();
//
//    // Some obviously cases: �޷���ϳ���Բ����Բ�ߴ����ͼ��ߴ磬Բ����ͼ����
//    if (ellipse_error < 0)
//        return false;
//    if (fitres.center.x < 0 || fitres.center.x >= iROWS || fitres.center.y < 0 || fitres.center.y > iCOLS)
//        return false;
//    if (fitres.size.height * fitres.size.width > iROWS * iCOLS)
//        return false;
//
//    return true;
//}
//void FLED::ElliFit(double *data, double &error, cv::RotatedRect &res)
//{
//    double rp[5];
//    double a1p, a2p, a11p, a22p, C2, alpha[9];
//    int dot_num = data[14];
//    // Mat buf_fit_data(6, 6, CV_64FC1, _buf_fit_data);
//    cv::Point2d cen_dot(data[12] / (2 * dot_num), data[13] / (2 * dot_num)); // the center of the fitting data.
//
//    double A[9], B[9], D[9], C[9], B_invD_Bt[9], lambda;
//    cv::Mat mB(3, 3, CV_64FC1, B), mD(3, 3, CV_64FC1, D), mB_invD_Bt(3, 3, CV_64FC1, B_invD_Bt);
//    A[0] = data[0] - 2 * cen_dot.x * data[3] + 6 * cen_dot.x * cen_dot.x * data[5] - 3 * dot_num * pow(cen_dot.x, 4);
//    A[3] = A[1] = data[1] - 3 * cen_dot.x * data[4] + 3 * cen_dot.x * cen_dot.x * data[8] - cen_dot.y * data[3] + cen_dot.x * cen_dot.y * 6 * data[5] - 6 * dot_num * cen_dot.y * pow(cen_dot.x, 3);
//    A[6] = A[2] = data[2] - cen_dot.y * data[4] + cen_dot.y * cen_dot.y * data[5] - cen_dot.x * data[7] / 2 + cen_dot.x * cen_dot.y * data[8] * 2 + cen_dot.x * cen_dot.x * data[11] - 3 * dot_num * pow(cen_dot.x * cen_dot.y, 2);
//    B[0] = data[3] - 6 * cen_dot.x * data[5] + 4 * dot_num * pow(cen_dot.x, 3);
//    B[1] = data[4] - cen_dot.x * data[8] * 2 - 2 * cen_dot.y * data[5] + 4 * dot_num * cen_dot.x * cen_dot.x * cen_dot.y;
//    B[2] = data[5] - dot_num * cen_dot.x * cen_dot.x;
//
//    A[4] = 4 * A[2];
//    A[7] = A[5] = data[6] - 1.5 * cen_dot.y * data[7] + 3 * cen_dot.y * cen_dot.y * data[8] - cen_dot.x * data[10] + 6 * cen_dot.x * cen_dot.y * data[11] - 6 * dot_num * cen_dot.x * pow(cen_dot.y, 3);
//    B[3] = 2 * B[1];
//    B[4] = data[7] - 4 * cen_dot.y * data[8] - 4 * cen_dot.x * data[11] + 8 * dot_num * cen_dot.x * cen_dot.y * cen_dot.y;
//    B[5] = data[8] - 2 * dot_num * cen_dot.x * cen_dot.y;
//
//    A[8] = data[9] - 2 * cen_dot.y * data[10] + 6 * cen_dot.y * cen_dot.y * data[11] - 3 * dot_num * pow(cen_dot.y, 4);
//    B[6] = B[4] / 2;
//    B[7] = data[10] - 6 * cen_dot.y * data[11] + 4 * dot_num * pow(cen_dot.y, 3);
//    B[8] = data[11] - dot_num * cen_dot.y * cen_dot.y;
//
//    D[0] = 4 * B[2];
//    D[3] = D[1] = 2 * B[5];
//    D[2] = 0;
//
//    D[4] = 4 * B[8];
//    D[5] = D[6] = D[7] = 0;
//    D[8] = dot_num;
//
//    mB_invD_Bt = mB * mD.inv() * mB.t();
//    double *_mB_invD_Bt = (double *)mB_invD_Bt.data;
//    for (int i = 0; i < 9; i++)
//        C[i] = A[i] - _mB_invD_Bt[i];
//
//    double detC, temp, detC22;
//    detC = C[0] * (C[4] * C[8] - C[5] * C[7]) - C[1] * (C[3] * C[8] - C[5] * C[6]) + C[2] * (C[3] * C[7] - C[4] * C[6]);
//    temp = (C[0] * C[4] - C[1] * C[1]);
//    if (abs(temp) < 1e-6)
//    {
//        error = -1;
//        return;
//    }
//    lambda = detC / temp;
//    error = lambda;
//
//    detC22 = C[0] * C[4] - C[3] * C[1];
//    if (abs(detC22) < 1e-6)
//    {
//        error = -1;
//        return;
//    }
//
//    alpha[0] = -(C[2] * C[4] - C[5] * C[1]) / detC22;
//    alpha[1] = -(C[0] * C[5] - C[3] * C[2]) / detC22;
//    alpha[2] = 1;
//
//    Mat invD_B = mD.inv() * mB.t();
//    double *_invD_B = (double *)invD_B.data;
//    alpha[3] = -(_invD_B[0] * alpha[0] + _invD_B[1] * alpha[1] + _invD_B[2] * alpha[2]);
//    alpha[4] = -(_invD_B[3] * alpha[0] + _invD_B[4] * alpha[1] + _invD_B[5] * alpha[2]);
//    alpha[5] = -(_invD_B[6] * alpha[0] + _invD_B[7] * alpha[1] + _invD_B[8] * alpha[2]);
//
//    double *_dls_X = alpha;
//    double dls_k = _dls_X[0] * _dls_X[2] - _dls_X[1] * _dls_X[1];
//    for (int i = 0; i < 6; i++)
//        _dls_X[i] /= sqrt(abs(dls_k));
//
//    rp[0] = _dls_X[1] * _dls_X[4] - _dls_X[2] * _dls_X[3];
//    rp[1] = _dls_X[1] * _dls_X[3] - _dls_X[0] * _dls_X[4];
//    if (fabs(_dls_X[0] - _dls_X[2]) > 1e-10)
//        rp[4] = atan(2 * _dls_X[1] / (_dls_X[0] - _dls_X[2])) / 2;
//    else
//    {
//        if (_dls_X[1] > 0)
//            rp[4] = CV_PI / 4;
//        else
//            rp[4] = -CV_PI / 4;
//    }
//    // ������ϳ����Ĳ�����Ϣ�������Ͻ�0,0λ��Ϊԭ�㣬rowΪx�ᣬcolΪy��Ϊ��׼��
//    a1p = cos(rp[4]) * _dls_X[3] + sin(rp[4]) * _dls_X[4];
//    a2p = -sin(rp[4]) * _dls_X[3] + cos(rp[4]) * _dls_X[4];
//    a11p = _dls_X[0] + tan(rp[4]) * _dls_X[1];
//    a22p = _dls_X[2] - tan(rp[4]) * _dls_X[1];
//    C2 = a1p * a1p / a11p + a2p * a2p / a22p - _dls_X[5];
//    double dls_temp1 = C2 / a11p, dls_temp2 = C2 / a22p, dls_temp;
//    if (dls_temp1 > 0 && dls_temp2 > 0)
//    {
//        rp[2] = sqrt(dls_temp1);
//        rp[3] = sqrt(dls_temp2);
//        if (rp[2] < rp[3])
//        {
//            if (rp[4] >= 0)
//                rp[4] -= CV_PI / 2;
//            else
//                rp[4] += CV_PI / 2;
//            dls_temp = rp[2];
//            rp[2] = rp[3];
//            rp[3] = dls_temp;
//        }
//    }
//    else
//    {
//        error = -2;
//        return;
//    }
//    res.center.x = (rp[0] + cen_dot.x) * PIXEL_SCALE;
//    res.center.y = (rp[1] + cen_dot.y) * PIXEL_SCALE;
//    res.size.width = 2 * rp[2] * PIXEL_SCALE;
//    res.size.height = 2 * rp[3] * PIXEL_SCALE;
//    res.angle = rp[4] / CV_PI * 180;
//}
//void FLED::fitEllipse(double *data, double &error, cv::RotatedRect &res)
//{
//    double rp[5], _buf_fit_data[36];
//    double a1p, a2p, a11p, a22p, C2;
//    int dot_num = data[14];
//    Mat buf_fit_data(6, 6, CV_64FC1, _buf_fit_data);
//    cv::Point2d cen_dot(data[12] / (2 * dot_num), data[13] / (2 * dot_num)); // the center of the fitting data.
//
//    _buf_fit_data[0] = data[0] - 2 * cen_dot.x * data[3] + 6 * cen_dot.x * cen_dot.x * data[5] - 3 * dot_num * pow(cen_dot.x, 4);
//    _buf_fit_data[1] = data[1] - 3 * cen_dot.x * data[4] + 3 * cen_dot.x * cen_dot.x * data[8] - cen_dot.y * data[3] + cen_dot.x * cen_dot.y * 6 * data[5] - 6 * dot_num * cen_dot.y * pow(cen_dot.x, 3);
//    _buf_fit_data[2] = data[2] - cen_dot.y * data[4] + cen_dot.y * cen_dot.y * data[5] - cen_dot.x * data[7] / 2 + cen_dot.x * cen_dot.y * data[8] * 2 + cen_dot.x * cen_dot.x * data[11] - 3 * dot_num * pow(cen_dot.x * cen_dot.y, 2);
//    _buf_fit_data[3] = data[3] - 6 * cen_dot.x * data[5] + 4 * dot_num * pow(cen_dot.x, 3);
//    _buf_fit_data[4] = data[4] - cen_dot.x * data[8] * 2 - 2 * cen_dot.y * data[5] + 4 * dot_num * cen_dot.x * cen_dot.x * cen_dot.y;
//    _buf_fit_data[5] = data[5] - dot_num * cen_dot.x * cen_dot.x;
//
//    _buf_fit_data[1 * 6 + 1] = 4 * _buf_fit_data[2];
//    _buf_fit_data[1 * 6 + 2] = data[6] - 1.5 * cen_dot.y * data[7] + 3 * cen_dot.y * cen_dot.y * data[8] - cen_dot.x * data[10] + 6 * cen_dot.x * cen_dot.y * data[11] - 6 * dot_num * cen_dot.x * pow(cen_dot.y, 3);
//    _buf_fit_data[1 * 6 + 3] = 2 * _buf_fit_data[4];
//    _buf_fit_data[1 * 6 + 4] = data[7] - 4 * cen_dot.y * data[8] - 4 * cen_dot.x * data[11] + 8 * dot_num * cen_dot.x * cen_dot.y * cen_dot.y;
//    _buf_fit_data[1 * 6 + 5] = data[8] - 2 * dot_num * cen_dot.x * cen_dot.y;
//
//    _buf_fit_data[2 * 6 + 2] = data[9] - 2 * cen_dot.y * data[10] + 6 * cen_dot.y * cen_dot.y * data[11] - 3 * dot_num * pow(cen_dot.y, 4);
//    _buf_fit_data[2 * 6 + 3] = _buf_fit_data[1 * 6 + 4] / 2;
//    _buf_fit_data[2 * 6 + 4] = data[10] - 6 * cen_dot.y * data[11] + 4 * dot_num * pow(cen_dot.y, 3);
//    _buf_fit_data[2 * 6 + 5] = data[11] - dot_num * cen_dot.y * cen_dot.y;
//
//    _buf_fit_data[3 * 6 + 3] = 4 * _buf_fit_data[5];
//    _buf_fit_data[3 * 6 + 4] = 2 * _buf_fit_data[1 * 6 + 5];
//    _buf_fit_data[3 * 6 + 5] = 0;
//
//    _buf_fit_data[4 * 6 + 4] = 4 * _buf_fit_data[2 * 6 + 5];
//    _buf_fit_data[4 * 6 + 5] = 0;
//
//    _buf_fit_data[5 * 6 + 5] = dot_num;
//    for (int i = 0; i < 6; i++)
//    {
//        for (int j = i + 1; j < 6; j++)
//        {
//            _buf_fit_data[j * 6 + i] = _buf_fit_data[i * 6 + j];
//        }
//    }
//    double t1, t2;
//    // t1 = cv::getTickCount();
//    // ElliFit(data, error, res);
//    // t2 = (double)cv::getTickCount();
//    eigen(buf_fit_data, dls_D, dls_V);
//    // cout << buf_fit_data << endl;
//
//    // cout << "ElliFit Time:" << (t2 - t1) * 1000 / cv::getTickFrequency() << endl;
//    // sum_time += (t2 - t1) * 1000 / cv::getTickFrequency();
//    // cout << dls_D << '\n' << dls_V << endl;
//    double *_dls_D = (double *)dls_D.data;
//    if (_dls_D[5] > 1e-10)
//    {
//        for (int i = 0; i < 6; i++)
//            dls_V.row(i) = dls_V.row(i) / sqrt(fabs(_dls_D[i]));
//        buf_fit_data = dls_V * dls_C * dls_V.t();
//        eigen(buf_fit_data, dls_D2, dls_V2);
//        //		cout << dls_D2 << '\n' << dls_V2 << endl;
//        double *_dls_D2 = (double *)dls_D2.data;
//        if (_dls_D2[0] > 0)
//        {
//            error = PIXEL_SCALE * PIXEL_SCALE / _dls_D2[0] / dot_num;
//            dls_X = dls_V2.row(0) * dls_V;
//        }
//        else
//        {
//            error = -1;
//            return;
//        }
//    }
//    else
//        dls_X = dls_V.row(5);
//    // cout << dls_X << endl;
//    // system("pause");
//    double *_dls_X = (double *)dls_X.data;
//    double dls_k = _dls_X[0] * _dls_X[2] - _dls_X[1] * _dls_X[1];
//    dls_X = dls_X / sqrt(abs(dls_k));
//
//    rp[0] = _dls_X[1] * _dls_X[4] - _dls_X[2] * _dls_X[3];
//    rp[1] = _dls_X[1] * _dls_X[3] - _dls_X[0] * _dls_X[4];
//    if (fabs(_dls_X[0] - _dls_X[2]) > 1e-10)
//        rp[4] = atan(2 * _dls_X[1] / (_dls_X[0] - _dls_X[2])) / 2;
//    else
//    {
//        if (_dls_X[1] > 0)
//            rp[4] = CV_PI / 4;
//        else
//            rp[4] = -CV_PI / 4;
//    }
//    // ������ϳ����Ĳ�����Ϣ�������Ͻ�0,0λ��Ϊԭ�㣬rowΪx�ᣬcolΪy��Ϊ��׼��
//    a1p = cos(rp[4]) * _dls_X[3] + sin(rp[4]) * _dls_X[4];
//    a2p = -sin(rp[4]) * _dls_X[3] + cos(rp[4]) * _dls_X[4];
//    a11p = _dls_X[0] + tan(rp[4]) * _dls_X[1];
//    a22p = _dls_X[2] - tan(rp[4]) * _dls_X[1];
//    C2 = a1p * a1p / a11p + a2p * a2p / a22p - _dls_X[5];
//    double dls_temp1 = C2 / a11p, dls_temp2 = C2 / a22p, dls_temp;
//    if (dls_temp1 > 0 && dls_temp2 > 0)
//    {
//        rp[2] = sqrt(dls_temp1);
//        rp[3] = sqrt(dls_temp2);
//        if (rp[2] < rp[3])
//        {
//            if (rp[4] >= 0)
//                rp[4] -= CV_PI / 2;
//            else
//                rp[4] += CV_PI / 2;
//            dls_temp = rp[2];
//            rp[2] = rp[3];
//            rp[3] = dls_temp;
//        }
//    }
//    else
//    {
//        error = -2;
//        return;
//    }
//    res.center.x = (rp[0] + cen_dot.x) * PIXEL_SCALE;
//    res.center.y = (rp[1] + cen_dot.y) * PIXEL_SCALE;
//    res.size.width = 2 * rp[2] * PIXEL_SCALE;
//    res.size.height = 2 * rp[3] * PIXEL_SCALE;
//    res.angle = rp[4] / CV_PI * 180;
//}
//
//void FLED::calCannyThreshold(cv::Mat &ImgG, int &low, int &high)
//{
//    Mat ImgT, dx, dy, grad;
//    cv::resize(ImgG, ImgT, cv::Size(ImgG.cols / 10, ImgG.rows / 10));
//    cv::Sobel(ImgT, dx, CV_16SC1, 1, 0);
//    cv::Sobel(ImgT, dy, CV_16SC1, 0, 1);
//    short *_dx = (short *)dx.data, *_dy = (short *)dy.data;
//
//    int subpixel_num = dx.rows * dx.cols;
//    grad.create(1, subpixel_num, CV_32SC1);
//    int *_grad = (int *)grad.data;
//    int maxGrad(0);
//    for (int i = 0; i < subpixel_num; i++)
//    {
//        _grad[i] = std::abs(_dx[i]) + std::abs(_dy[i]);
//        if (maxGrad < _grad[i])
//            maxGrad = _grad[i];
//    }
//
//    // set magic numbers
//    const int NUM_BINS = 64;
//    const double percent_of_pixels_not_edges = 0.7;
//    const double threshold_ratio = 0.4;
//    int bins[NUM_BINS] = {0};
//
//    // compute histogram
//#if defined(__GNUC__)
//    int bin_size = std::floor(maxGrad / float(NUM_BINS) + 0.5f) + 1;
//#else
//    int bin_size = std::floorf(maxGrad / float(NUM_BINS) + 0.5f) + 1;
//#endif
//    if (bin_size < 1)
//        bin_size = 1;
//    for (int i = 0; i < subpixel_num; i++)
//    {
//        bins[_grad[i] / bin_size]++;
//    }
//
//    //% Select the thresholds
//    float total(0.f);
//    float target = float(subpixel_num * percent_of_pixels_not_edges);
//
//    high = 0;
//    while (total < target)
//    {
//        total += bins[high];
//        high++;
//    }
//    //	high *= bin_size;
//    high *= (255.0f / NUM_BINS);
//    //	low = std::min((int)std::floor(threshold_ratio * float(high)), 30);
//    low = threshold_ratio * float(high);
//}
//
//void FLED::CreateArcSearchRegion(vector<vector<Point>> &fsaarcs)
//{
//
//    const int arc_num = fsaarcs.size();
//    Point *_arc_data = NULL;
//    int subarc_num;
//    ArcSearchRegion asrTemp;
//
//    //	asrs.resize(arc_num);
//
//    for (int i = 0; i < arc_num; i++)
//    {
//        subarc_num = fsaarcs[i].size();
//        _arc_data = fsaarcs[i].data();
//        asrTemp.create(_arc_data, _arc_data + 1, _arc_data + subarc_num - 2, _arc_data + subarc_num - 1);
//        asrs.push_back(asrTemp);
//    }
//}
//
//void FLED::PosteriorArcsSearch2(int point_idx)
//{
//    const int arcs_num = FSA_ArcContours.size(), group_num = temp.size();
//    char *_link_data = LinkMatrix.GetDataPoint();
//    int idx_use;
//    bool isValid = true, noArcs = false;
//    ArcSearchRegion *_asrs_data = asrs.data();
//
//    char check_val, temp_val;
//    int find_now_idx = -1, find_arc_idx;
//    vector<Point> *single_arc = NULL;
//
//    // 创建当前组合弧段的搜索区间
//    Point *_st_data(NULL), *_ed_data(NULL);
//    int grouped_st_idx, grouped_ed_idx, grouped_ed_arc_num;
//    ArcSearchRegion grouped_arcs;
//
//    grouped_st_idx = temp[0], grouped_ed_idx = temp.back();
//    _st_data = FSA_ArcContours[grouped_st_idx].data();
//    grouped_ed_arc_num = FSA_ArcContours[grouped_ed_idx].size();
//    _ed_data = FSA_ArcContours[grouped_ed_idx].data();
//    grouped_arcs.create(_st_data, _st_data + 1, _ed_data + grouped_ed_arc_num - 2, _ed_data + grouped_ed_arc_num - 1);
//
//    while (1)
//    {
//        find_now_idx = lA[point_idx].findNextLinking(find_now_idx);
//        if (find_now_idx == -1) // 再也找不到可以组合的弧段
//        {
//            break;
//        }
//        find_arc_idx = lA[point_idx].idx_linking[find_now_idx]; // 获取弧段角标
//        if (*visited[find_arc_idx] != 0)                        // 访问过
//            continue;
//        if (_arc_grouped_label[find_arc_idx] != 0) // 被组合过
//            continue;
//
//        *visited[find_arc_idx] = 1;
//        *searched[find_arc_idx] = 1;
//        // 验证候选组合点的中心点是否在搜索区间内(考虑到首尾均可能与当前区域相连，只有中点不会造成区域约束的实效).
//        int single_num = FSA_ArcContours[find_arc_idx].size() / 2;
//        bool inSearch = grouped_arcs.isInSearchRegion(&(FSA_ArcContours[find_arc_idx][single_num]));
//        if (!inSearch)
//            continue;
//
//        // 验证是否满足第二个约束式
//        idx_use = find_arc_idx * arcs_num;
//        isValid = true;
//        for (int i = 0; i < group_num; i++)
//        {
//            int tmpData_i = temp[i];
//            check_val = _link_data[idx_use + tmpData_i];
//            if (check_val == 0) // L_{i,k} ==0 ,there needs to use CASE_1 to varify whether L_{i,k} = -1.
//            {
//                temp_val = CASE_1(_asrs_data + point_idx, _asrs_data + tmpData_i);
//                if (temp_val == -1)
//                {
//                    _link_data[idx_use + tmpData_i] = _link_data[tmpData_i * arcs_num + point_idx] = -1;
//                    isValid = false;
//                    break;
//                }
//            }
//            else if (check_val == -1)
//            {
//                isValid = false;
//                break;
//            }
//        }
//        if (isValid == false)
//            continue;
//
//        // 这个点是有效的
//        temp.push_back(find_arc_idx);
//        push_fitmat(fitArcTemp.val, ArcFitMat[find_arc_idx].val, MAT_NUMBER);
//        PosteriorArcsSearch2(find_arc_idx);
//    }
//
//    // 到这说明没有弧段可以组合了，获得当前组合，然后退掉一个点
//    search_group[0].push_back(temp);         // 得到一个组合
//    search_arcMats[0].push_back(fitArcTemp); // 存储对应组合的拟合矩阵
//
//    pop_fitmat(fitArcTemp.val, ArcFitMat[temp.back()].val, MAT_NUMBER); // 删掉最后一个点的拟合矩阵
//    temp.pop_back();
//    *visited[point_idx] = 0;
//}
//void FLED::PosteriorArcsSearch(int point_idx)
//{
//    const int arcs_num = FSA_ArcContours.size(), group_num = temp.size();
//    char *_link_data = LinkMatrix.GetDataPoint();
//    int idx_use = point_idx * arcs_num;
//    bool isValid = true;
//    ArcSearchRegion *_asrs_data = asrs.data();
//
//    int *_temp_data = temp.data();
//    char check_val, temp_val;
//    // 检查当前点与其他组合点是否可相连 Linking Search the 2th search constraint
//    for (int i = 0; i < group_num - 1; i++)
//    {
//        check_val = _link_data[idx_use + _temp_data[i]];
//        if (check_val == 0) // L_{i,k} ==0 ,there needs to use CASE_1 to varify whether L_{i,k} = -1.
//        {
//            temp_val = CASE_1(_asrs_data + point_idx, _asrs_data + _temp_data[i]);
//            if (temp_val == -1)
//            {
//                _link_data[idx_use + _temp_data[i]] = _link_data[_temp_data[i] * arcs_num + point_idx] = -1;
//                isValid = false;
//                break;
//            }
//        }
//        else if (check_val == -1)
//        {
//            isValid = false;
//            break;
//        }
//    }
//
//    if (isValid == false)
//    {
//        search_group[0].push_back(temp);         // 得到一个组合
//        search_arcMats[0].push_back(fitArcTemp); // 存储对应组合的拟合矩阵
//
//        pop_fitmat(fitArcTemp.val, ArcFitMat[temp.back()].val, MAT_NUMBER); // 删掉最后一个点的拟合矩阵
//        temp.pop_back();
//        *visited[point_idx] = 0;
//
//        return;
//    }
//
//    int find_now_idx = -1;
//    while (1)
//    {
//        find_now_idx = lA[point_idx].findNextLinking(find_now_idx);
//        if (find_now_idx < 0) // 没有可以相连的弧段
//        {
//            search_group[0].push_back(temp);                                    // 得到一个组合
//            search_arcMats[0].push_back(fitArcTemp);                            // 存储对应组合的拟合矩阵
//            pop_fitmat(fitArcTemp.val, ArcFitMat[temp.back()].val, MAT_NUMBER); // 删掉最后一个点的拟合矩阵
//            temp.pop_back();
//            *visited[point_idx] = 0;
//            break;
//        }
//
//        int find_arc_idx = lA[point_idx].idx_linking[find_now_idx];
//        if (*visited[find_arc_idx] != 0)
//            continue;
//        if (_arc_grouped_label[find_arc_idx] != 0)
//            continue;
//        *visited[find_arc_idx] = 1;
//        *searched[find_arc_idx] = 1;
//        temp.push_back(find_arc_idx);
//        push_fitmat(fitArcTemp.val, ArcFitMat[find_arc_idx].val, MAT_NUMBER);
//        PosteriorArcsSearch(find_arc_idx);
//    }
//}
//
//void FLED::AnteriorArcsSearch2(int point_idx)
//{
//    const int arcs_num = FSA_ArcContours.size(), group_num = temp.size();
//    char *_link_data = LinkMatrix.GetDataPoint();
//    int idx_use;
//    bool isValid = true, noArcs = false;
//    ArcSearchRegion *_asrs_data = asrs.data();
//
//    int *_temp_data = temp.data();
//    char check_val, temp_val;
//    int find_now_idx = -1, find_arc_idx;
//    vector<Point> *single_arc = NULL;
//
//    // 创建当前组合弧段的搜索区间
//    Point *_st_data(NULL), *_ed_data(NULL);
//    int grouped_st_idx, grouped_ed_idx, grouped_ed_arc_num;
//    ArcSearchRegion grouped_arcs;
//
//    // 与前面不同的是，搜索点的顺序需要调换
//    grouped_st_idx = _temp_data[group_num - 1], grouped_ed_idx = _temp_data[0];
//    _st_data = FSA_ArcContours[grouped_st_idx].data();
//    grouped_ed_arc_num = FSA_ArcContours[grouped_ed_idx].size();
//    _ed_data = FSA_ArcContours[grouped_ed_idx].data();
//    grouped_arcs.create(_st_data, _st_data + 1, _ed_data + grouped_ed_arc_num - 2, _ed_data + grouped_ed_arc_num - 1);
//
//    while (1)
//    {
//        find_now_idx = lA[point_idx].findNextLinked(find_now_idx);
//        if (find_now_idx == -1) // 再也找不到可以组合的弧段
//        {
//            break;
//        }
//        find_arc_idx = lA[point_idx].idx_linked[find_now_idx]; // 获取弧段角标
//        if (*visited[find_arc_idx] != 0)                       // 访问过
//            continue;
//        if (_arc_grouped_label[find_arc_idx] != 0) // 被组合过
//            continue;
//        if (*searched[find_arc_idx] != 0) // 被之前算法搜索过
//            continue;
//
//        *visited[find_arc_idx] = 1;
//
//        // 验证候选组合点的中心点是否在搜索区间内(考虑到首尾均可能与当前区域相连，只有中点不会造成区域约束的实效).
//        int single_num = FSA_ArcContours[find_arc_idx].size() / 2;
//        bool inSearch = grouped_arcs.isInSearchRegion(&(FSA_ArcContours[find_arc_idx][single_num]));
//        if (!inSearch)
//            continue;
//
//        // 验证是否满足第二个约束式
//        idx_use = find_arc_idx * arcs_num;
//        isValid = true;
//        for (int i = 0; i < group_num; i++)
//        {
//            check_val = _link_data[_temp_data[i] * arcs_num + find_arc_idx];
//            //			check_val = _link_data[idx_use + _temp_data[i]];
//            if (check_val == 0) // L_{i,k} ==0 ,there needs to use CASE_1 to varify whether L_{i,k} = -1.
//            {
//                temp_val = CASE_1(_asrs_data + _temp_data[i], _asrs_data + point_idx);
//                if (temp_val == -1)
//                {
//                    _link_data[idx_use + _temp_data[i]] = _link_data[_temp_data[i] * arcs_num + point_idx] = -1;
//                    isValid = false;
//                    break;
//                }
//            }
//            else if (check_val == -1)
//            {
//                isValid = false;
//                break;
//            }
//        }
//        if (isValid == false)
//            continue;
//
//        // 这个点是有效的
//        temp.push_back(find_arc_idx);
//        push_fitmat(fitArcTemp.val, ArcFitMat[find_arc_idx].val, MAT_NUMBER);
//        AnteriorArcsSearch2(find_arc_idx);
//    }
//
//    // 到这说明没有弧段可以组合了，获得当前组合，然后退掉一个点
//    search_group[1].push_back(temp);         // 得到一个组合
//    search_arcMats[1].push_back(fitArcTemp); // 存储对应组合的拟合矩阵
//
//    pop_fitmat(fitArcTemp.val, ArcFitMat[temp.back()].val, MAT_NUMBER); // 删掉最后一个点的拟合矩阵
//    temp.pop_back();
//    *visited[point_idx] = 0;
//}
//void FLED::AnteriorArcsSearch(int point_idx)
//{
//    const int arcs_num = FSA_ArcContours.size(), group_num = temp.size();
//    char *_link_data = LinkMatrix.GetDataPoint();
//    int idx_use = point_idx * arcs_num;
//    bool isValid = true;
//
//    ArcSearchRegion *_asrs_data = asrs.data();
//    int *_temp_data = temp.data();
//    char check_val, temp_val;
//
//    // 检查当前点与其他组合点是否可相连 Linking Search the 2th search constraint
//    for (int i = 0; i < group_num - 1; i++)
//    {
//        check_val = _link_data[idx_use + _temp_data[i]];
//        if (check_val == 0)
//        {
//            temp_val = CASE_1(_asrs_data + point_idx, _asrs_data + _temp_data[i]);
//            if (temp_val == -1)
//            {
//                _link_data[idx_use + _temp_data[i]] = _link_data[_temp_data[i] * arcs_num + point_idx] = -1;
//                isValid = false;
//                break;
//            }
//        }
//        else if (check_val == -1)
//        {
//            isValid = false;
//            break;
//        }
//    }
//    if (/*temp.size() > MAX_COMBINATION_ARCS ||*/ isValid == false)
//    {
//        search_group[1].push_back(temp);         // 得到一个组合
//        search_arcMats[1].push_back(fitArcTemp); // 存储对应组合的拟合矩阵
//
//        pop_fitmat(fitArcTemp.val, ArcFitMat[temp.back()].val, MAT_NUMBER); // 删掉最后一个点的拟合矩阵
//        temp.pop_back();
//
//        *visited[point_idx] = 0;
//        return;
//    }
//
//    int find_now_idx = -1;
//    while (1)
//    {
//        find_now_idx = lA[point_idx].findNextLinked(find_now_idx);
//        if (find_now_idx < 0) // 搜不到新点
//        {
//            search_group[1].push_back(temp);
//            search_arcMats[1].push_back(fitArcTemp);
//
//            pop_fitmat(fitArcTemp.val, ArcFitMat[temp.back()].val, MAT_NUMBER); // 删掉最后一个点的拟合矩阵
//            temp.pop_back();
//            *visited[point_idx] = 0;
//            break;
//        }
//        int find_arc_idx = lA[point_idx].idx_linked[find_now_idx];
//
//        if (*visited[find_arc_idx] != 0)
//            continue;
//        if (_arc_grouped_label[find_arc_idx] != 0)
//            continue;
//        if (*searched[find_arc_idx] != 0)
//            continue;
//        *visited[find_arc_idx] = 1;
//        push_fitmat(fitArcTemp.val, ArcFitMat[find_arc_idx].val, MAT_NUMBER);
//        temp.push_back(find_arc_idx);
//        AnteriorArcsSearch(find_arc_idx);
//    }
//}
//
//void FLED::BiDirectionVerification(GPSD &fitComb, vector<cv::Vec<double, MAT_NUMBER>> fitMats[2], vector<vector<int>> link_group[2], vector<unsigned char> &arc_grouped)
//{
//
//#ifdef DETAIL_BREAKDOWN
//    double tmp_st = 0;
//#endif
//    int fit_num = fitComb.usesize(), idx_l, idx_r, num_idx_l, num_idx_r;
//    cv::RotatedRect fitelpres;
//
//    bool isCombValid = true;
//    int linked_num, linking_num, *_linked_data(NULL), *_linking_data(NULL), idx_link;
//    char *_link_data = LinkMatrix.GetDataPoint();
//    int arcs_num = FSA_ArcContours.size();
//
//    // isBIDIR = 0;
//
//    int max_idx(-1), max_idx_l, max_idx_r;
//    double max_score(-1);
//    cv::RotatedRect max_ellipse;
//
//    for (int i = 0; i < fit_num; i++)
//    {
//        if (fitComb[i]->val < 0) // 判断是否有效
//            break;
//        bool fitres;
//        // t1 = cv::getTickCount();
//        idx_l = fitComb[i]->idx_l;
//        idx_r = fitComb[i]->idx_r;
//        if (idx_l >= 0 && idx_r >= 0)
//        {
//            linked_num = link_group[1][idx_l].size(), linking_num = link_group[0][idx_r].size();
//            _linked_data = link_group[1][idx_l].data();
//            _linking_data = link_group[0][idx_r].data();
//            for (int k = 0; k < linked_num; k++)
//            {
//                idx_link = _linked_data[k] * arcs_num;
//                for (int p = 0; p < linking_num; p++)
//                {
//                    if (_link_data[idx_link + _linking_data[p]] == -1)
//                    {
//                        isCombValid = false;
//                        break;
//                    }
//                }
//                if (isCombValid == false)
//                    break;
//            }
//            if (isCombValid == false) // 两个弧段不能组合
//                continue;
//            fitres = FittingConstraint(fitMats[0][idx_r].val, fitMats[1][idx_l].val, fitelpres);
//
//            // isBIDIR = 10; //说明开始组合
//        }
//        else if (idx_l >= 0)
//            fitres = FittingConstraint(NULL, fitMats[1][idx_l].val, fitelpres);
//        else if (idx_r >= 0)
//            fitres = FittingConstraint(fitMats[0][idx_r].val, NULL, fitelpres);
//        // t2 = (double)cv::getTickCount();
//        // cout << "ElliFit Time: " << (t2 - t1) * 1000 / cv::getTickFrequency() << endl;
//        // sum_time += 1;/// (t2 - t1) * 1000 / cv::getTickFrequency();
//
//        if (fitres == false)
//            continue;
//
//        // t1 = cv::getTickCount();
//        // 利用validate进行比较
//        double detScore;
//
//#ifdef DETAIL_BREAKDOWN
//        tmp_st = cv::getTickCount();
//#endif
//
//        fitres = fastValidation(fitelpres, &detScore);
//
//#ifdef DETAIL_BREAKDOWN
//        t_allvalidation += (cv::getTickCount() - tmp_st) * 1000 / cv::getTickFrequency();
//        valitation_time++;
//#endif
//        if (fitres == false)
//            continue;
//
//        // if (detScore > max_score)
//        //	max_idx = i, max_score = detScore, max_idx_l = idx_l, max_idx_r = idx_r, max_ellipse = fitelpres;
//
//        num_idx_l = idx_l >= 0 ? search_group[1][idx_l].size() : -1;
//        num_idx_r = idx_r >= 0 ? search_group[0][idx_r].size() : -1;
//        for (int k = 0; k < num_idx_l; k++)
//            arc_grouped[search_group[1][idx_l][k]] = 1;
//        for (int k = 0; k < num_idx_r; k++)
//            arc_grouped[search_group[0][idx_r][k]] = 1;
//        detEllipses.push_back(fitelpres);
//        detEllipseScore.push_back(detScore);
//
//        // if (isBIDIR == 10)
//        //	cout << "这张图有两种方向拟合的结果" << endl;
//        break;
//    }
//    // if (max_idx < 0)
//    //	return;
//    // num_idx_l = max_idx_l >= 0 ? search_group[1][max_idx_l].size() : -1;
//    // num_idx_r = max_idx_r >= 0 ? search_group[0][max_idx_r].size() : -1;
//    // for (int k = 0; k < num_idx_l; k++)
//    //	arc_grouped[search_group[1][max_idx_l][k]] = 1;
//    // for (int k = 0; k < num_idx_r; k++)
//    //	arc_grouped[search_group[0][max_idx_r][k]] = 1;
//    // detEllipses.push_back(max_ellipse);
//    // detEllipseScore.push_back(max_score);
//}
//
//#if defined(__GNUC__)
//using namespace std;
//#endif
//
//void FLED::ClusterEllipses(std::vector<cv::RotatedRect> &detElps, vector<double> &detEllipseScore)
//{
//    const int ellipse_num = (int)detElps.size();
//    if (ellipse_num == 0)
//        return;
//
//    // The first ellipse is assigned to a cluster
//    std::vector<cv::RotatedRect> clusters;
//    std::vector<double> scores;
//    clusters.push_back(detElps[0]);
//    scores.push_back(detEllipseScore[0]);
//
//    bool bFoundCluster = false;
//
//    float th_Da = 0.12f;
//    float th_Db = 0.12f;
//    float th_Dc_ratio = 0.12f;
//
//    // float th_Dr = 0.13f;
//    float th_Dr = 30.0 / 180 * CV_PI;
//
//    float th_Dr_circle = 0.8f;
//
//    float loop_width = 10;
//
//    for (int i = 1; i < ellipse_num; i++)
//    {
//        cv::RotatedRect &e1 = detElps[i];
//        int sz_clusters = int(clusters.size());
//
//        float ba_e1 = e1.size.height / e1.size.width;
//        float Decc1 = e1.size.height / e1.size.width;
//        float score_i = detEllipseScore[i];
//
//        bool bFoundCluster = false;
//        for (int j = 0; j < sz_clusters; ++j)
//        {
//            cv::RotatedRect &e2 = clusters[j];
//
//            float ba_e2 = e2.size.height / e2.size.width;
//            float th_Dc = std::min(e1.size.height, e2.size.height) * th_Dc_ratio;
//            if (th_Dc < 30 * th_Dc_ratio)
//                th_Dc = 30 * th_Dc_ratio;
//            th_Dc *= th_Dc;
//
//            // Centers
//            float Dc = ((e1.center.x - e2.center.x) * (e1.center.x - e2.center.x) + (e1.center.y - e2.center.y) * (e1.center.y - e2.center.y));
//            if (Dc > th_Dc)
//                continue;
//
//            // a
//            float Da = abs(e1.size.width - e2.size.width) / std::max(e1.size.width, e2.size.width);
//            if (Da > th_Da && abs(e1.size.width - e2.size.width) > loop_width)
//                continue;
//
//            // b
//            float Db = abs(e1.size.height - e2.size.height) / std::min(e1.size.height, e2.size.height);
//            if (Db > th_Db && abs(e1.size.height - e2.size.height) > loop_width)
//                continue;
//
//            // angle
//            float diff = std::abs(e1.angle - e2.angle) / 180 * CV_PI;
//            float Dr = diff < CV_PI / 2 ? diff : CV_PI - diff;
//            if ((Dr > th_Dr) && (ba_e1 < th_Dr_circle) && (ba_e2 < th_Dr_circle))
//            {
//                // not same cluster
//                continue;
//            }
//
//            // Score
//            float score_j = scores[j];
//
//            if (score_i > score_j)
//            {
//                clusters[j] = e1;
//                scores[j] = score_i;
//            }
//            // Same cluster as e2
//            bFoundCluster = true; //
//            // Discard, no need to create a new cluster
//            break;
//        }
//
//        if (!bFoundCluster)
//        {
//            // Create a new cluster
//            clusters.push_back(e1);
//            scores.push_back(score_i);
//        }
//    }
//
//    clusters.swap(detElps);
//    scores.swap(detEllipseScore);
//}
//
//bool FLED::Validation(cv::RotatedRect &res, double *detScore)
//{
//
//    //	return true;
//    float _ROT_GRAD[4], _ROT_TRANS[4];
//    float angleRot, xyCenter[2], R, r;
//    float m, E_score(0), w, sum_w(0), step, norm_li_gi;
//    int count1, count2;
//    Node_FC *node_temp, *node_next = NULL, *node_last = NULL;
//    Point l_i;
//    Point2f g_i;
//    int length_l_i_2, length_g_i_2;
//    angleRot = res.angle / 180 * CV_PI;                     // The ellipse rotation angle.
//    xyCenter[0] = res.center.x, xyCenter[1] = res.center.y; // The ellipse center xy.
//    R = res.size.width / 2, r = res.size.height / 2;        // The major-axis and minor-axis.
//    m = r / R;
//    // I_0(R,r).  Note: sqrt(2) -1 ~= 0.414213562373095
//    if (4 * R * r < _T_min_minor * _T_min_minor)
//        return false;
//
//    // if (R*r < _T_min_minor*_T_min_minor*0.25)
//    //	return false;
//
//    if (R * r < _T_dp / (0.414213562373095) * sqrt(R * R + r * r))
//        return false;
//
//    // if (R/r > 30)
//    //	cout << "ERROR" << endl;
//    m = r / R;
//
//    _ROT_TRANS[0] = R * cos(angleRot), _ROT_TRANS[1] = -r * sin(angleRot);
//    _ROT_TRANS[2] = R * sin(angleRot), _ROT_TRANS[3] = r * cos(angleRot);
//
//    _ROT_GRAD[0] = -r * sin(angleRot), _ROT_GRAD[1] = -R * cos(angleRot);
//    _ROT_GRAD[2] = r * cos(angleRot), _ROT_GRAD[3] = -R * sin(angleRot);
//
//    uchar *_boldData = (uchar *)imgCanny.data;
//    const int vld_num = _T_gradnum;
//
//    // Estimate the sampling points number N. Note: N = RoundEllipseCircum;
//    int RoundEllipseCircum = int((R + r) * CV_PI);
//    if (RoundEllipseCircum > 360)
//        RoundEllipseCircum = 360;
//    step = 360.0 / RoundEllipseCircum;
//
//    int x, y, idxdxy, idxixy, angle_idx;
//    int xOffset, yOffset, xReal, yReal, idxdxyReal;
//    float vldBaseData_x, vldBaseData_y;
//
//    // if (R / r > RoundEllipseCircum / 8)
//    //	return false;
//#if DEFINITE_ERROR_BOUNDED
//    const int Prasad_R = 10;
//    Point n;
//    double dist, min_dist;
//    Node_FC *node_center = NULL;
//#endif
//
//    for (int i = 0; i < RoundEllipseCircum; i++)
//    {
//        angle_idx = round(i * step);
//        if (angle_idx >= VALIDATION_NUMBER)
//        {
//            RoundEllipseCircum = i;
//            break;
//        }
//        vldBaseData_x = vldBaseData[angle_idx][0], vldBaseData_y = vldBaseData[angle_idx][1];
//        w = m / (m * m * vldBaseData_x * vldBaseData_x + vldBaseData_y * vldBaseData_y);
//        // w = 1;
//        sum_w += w;
//        // Get a sample point
//        x = _ROT_TRANS[0] * vldBaseData_x + _ROT_TRANS[1] * vldBaseData_y + xyCenter[0];
//        y = _ROT_TRANS[2] * vldBaseData_x + _ROT_TRANS[3] * vldBaseData_y + xyCenter[1];
//        if (OutOfRange(x, y))
//            continue;
//        idxdxy = dIDX(x, y);
//        idxixy = iIDX(x, y);
//        // I_1(V_i)
//        if (_boldData[idxixy] != 0)
//        {
//            // get the real point on the edge map.
//            xOffset = _boldData[idxixy] / 10;
//            yOffset = _boldData[idxixy] - 10 * xOffset;
//            xOffset = xOffset - 1;
//            yOffset = yOffset - 2;
//            xReal = x - xOffset;
//            yReal = y - yOffset;
//            idxdxyReal = dIDX(xReal, yReal);
//
//            // estimate the grad of this point.
//#if DEFINITE_ERROR_BOUNDED
//            node_center = data + idxdxyReal;
//
//            node_next = node_temp = node_center;
//            node_temp = node_temp->nextAddress;
//            for (count1 = 0, min_dist = 100; node_temp != NULL && count1 < Prasad_R; count1++)
//            {
//                n.x = node_temp->Location.x - node_center->Location.x;
//                n.y = node_temp->Location.y - node_center->Location.y;
//                dist = fabs(sqrt(double(n.x * n.x + n.y * n.y)) - Prasad_R);
//                // dist = abs(abs(n.x) + abs(n.y) - Prasad_R);
//                if (dist <= min_dist)
//                    min_dist = dist, node_next = node_temp;
//                node_temp = node_temp->nextAddress;
//            }
//            node_last = node_temp = node_center;
//            node_temp = node_temp->lastAddress;
//            for (count2 = 0, min_dist = 100; node_temp != NULL && count2 < Prasad_R; count2++)
//            {
//                n.x = node_temp->Location.x - node_center->Location.x;
//                n.y = node_temp->Location.y - node_center->Location.y;
//                dist = fabs(sqrt(double(n.x * n.x + n.y * n.y)) - Prasad_R);
//                // dist = abs(abs(n.x) + abs(n.y) - Prasad_R);
//                if (dist <= min_dist)
//                    min_dist = dist, node_last = node_temp;
//                node_temp = node_temp->lastAddress;
//            }
//            // Grad l_i Estimation
//            l_i = node_next->Location - node_last->Location;
//#else
//            node_temp = data + idxdxyReal;
//            node_last = node_next = NULL;
//            for (count1 = 0; count1 < vld_num; count1++)
//            {
//                if (node_temp == NULL)
//                    break;
//                node_next = node_temp;
//                node_temp = node_temp->nextAddress;
//                //				node_next = node_next->nextAddress;
//            }
//            node_temp = data + idxdxyReal;
//            for (count2 = 0; count2 < vld_num; count2++)
//            {
//                if (node_temp == NULL)
//                    break;
//                node_last = node_temp;
//                node_temp = node_temp->lastAddress;
//            }
//            if (count1 + count2 < vld_num)
//                continue;
//            // Grad l_i Estimation
//            l_i = node_next->Location - node_last->Location;
//#endif
//            length_l_i_2 = l_i.x * l_i.x + l_i.y * l_i.y;
//            // Grad g_i Estimation
//            g_i.x = _ROT_GRAD[0] * vldBaseData_x + _ROT_GRAD[1] * vldBaseData_y;
//            g_i.y = _ROT_GRAD[2] * vldBaseData_x + _ROT_GRAD[3] * vldBaseData_y;
//            length_g_i_2 = g_i.x * g_i.x + g_i.y * g_i.y;
//            // |g_i * l_i| / (|g_i|*|l_i|)
//            norm_li_gi = abs(l_i.x * g_i.x + l_i.y * g_i.y) / sqrt(length_l_i_2 * length_g_i_2);
//            // norm_li_gi = 1;
//            if (norm_li_gi <= 0.707106781186548) // sqrt(2)/2 ~= 0.707106781186548
//                continue;
//            E_score += w * (norm_li_gi - 0.707106781186548) / (1 - 0.707106781186548);
//            // E_score += w;
//
//            // float grad[2], nl = lineGrad.x*lineGrad.x + lineGrad.y*lineGrad.y;
//            // grad[0] = _ROT_GRAD[0] * vldBaseData_x + _ROT_GRAD[1] * vldBaseData_y;
//            // grad[1] = _ROT_GRAD[2] * vldBaseData_x + _ROT_GRAD[3] * vldBaseData_y;
//            // float nl2 = grad[0] * grad[0] + grad[1] * grad[1];
//            // float csita = abs(lineGrad.x*grad[0] + lineGrad.y*grad[1]) / sqrt(nl*nl2);
//
//            // float alpha = acos(csita);
//            //// I_2(V_i)
//            // if (csita <= cos(CV_PI / 4))
//            //	continue;
//            // float I_2;
//            // if(csita > cos(CV_PI/8))
//            //	I_2 = (csita - cos(CV_PI / 4)) / (1 - cos(CV_PI / 4));
//            // else
//            //{
//            //	float I_2_t = (cos(CV_PI / 8) - cos(CV_PI / 4)) / (1 - cos(CV_PI / 4));
//            //	I_2 = (csita - cos(CV_PI / 4)) / (1 - cos(CV_PI / 4));
//            // }
//            // float I_2 = 10 * (csita - cos(CV_PI/8)) / (1 - cos(CV_PI / 8));
//            // I_2 = 1 / (1 + exp(-I_2));
//            // E_score += I_2*w;
//
//            // if (csita <= cos(CV_PI / 4))
//            //	continue;
//            // E_score += w*(csita - std::sqrt(2.0) / 2) / (1 - std::sqrt(2.0) / 2);
//        }
//    }
//
//    E_score = E_score / sum_w * RoundEllipseCircum;
//    if (E_score > RoundEllipseCircum * _T_val)
//    {
//        *detScore = E_score / RoundEllipseCircum;
//        return true;
//    }
//    else
//        return false;
//}
//
///*
//bool FLED::fastValidation(cv::RotatedRect &res, double *detScore)
//{
//    const float angleRot(res.angle / 180 * CV_PI),
//        xyCenter[2] = { res.center.x, res.center.y },
//        R(res.size.width / 2), r(res.size.height / 2);// The major-axis and minor-axis.
//
//    // Shape constraint I_0(R,r).  Note: sqrt(2) - 1 ~= 0.414213562373095
//
//    // Shape Index
//    if (R*r * 4 < _T_min_minor * _T_min_minor)
//        return false;
//    if (R*r < 2 * _T_dp / (0.414213562373095)*sqrt(R*R + r*r))
//        return false;
//
//    const float _ROT_TRANS[4] = { R * cos(angleRot), -r * sin(angleRot), R  * sin(angleRot), r  * cos(angleRot) },
//        _ROT_GRAD[4] = {-r*sin(angleRot), -R*cos(angleRot), r*cos(angleRot), -R*sin(angleRot)};
//
//    float m = r / R;
//
//    if (m < 0.2) { detScore = 0; return false; }
//    if (m < 0.4) m = 0.4;
//
//
//    // Use SSE to faster the step of ellipse validation.
//    __m256 _rot_trans_0 = _mm256_set1_ps(_ROT_TRANS[0]),
//        _rot_trans_1 = _mm256_set1_ps(_ROT_TRANS[1]),
//        _rot_trans_2 = _mm256_set1_ps(_ROT_TRANS[2]),
//        _rot_trans_3 = _mm256_set1_ps(_ROT_TRANS[3]);
//
//    __m256 _rot_grad_0 = _mm256_set1_ps(_ROT_GRAD[0]),
//        _rot_grad_1 = _mm256_set1_ps(_ROT_GRAD[1]),
//        _rot_grad_2 = _mm256_set1_ps(_ROT_GRAD[2]),
//        _rot_grad_3 = _mm256_set1_ps(_ROT_GRAD[3]);
//
//    __m256	x_center = _mm256_set1_ps(xyCenter[0]),
//        y_center = _mm256_set1_ps(xyCenter[1]);
//
//    __m256 mm = _mm256_set1_ps(m*m);
//    __m256 tmp_x, tmp_y, tmp_gx, tmp_gy, tmp_wx, tmp_wy, tmp_w;
//
//    for (int i = 0; i < VALIDATION_NUMBER; i += sizeof(__m256)/sizeof(float))
//    {
//        __m256 base_x = _mm256_load_ps(vldBaseDataX + i);
//        __m256 base_y = _mm256_load_ps(vldBaseDataY + i);
//        // calculate location x
//        tmp_x = _mm256_add_ps(
//            _mm256_mul_ps(_rot_trans_0, base_x),
//            _mm256_mul_ps(_rot_trans_1, base_y));
//        tmp_x = _mm256_add_ps(tmp_x, x_center);
//        // calculate location y
//        tmp_y = _mm256_add_ps(
//            _mm256_mul_ps(_rot_trans_2, base_x),
//            _mm256_mul_ps(_rot_trans_3, base_y));
//        tmp_y = _mm256_add_ps(tmp_y, y_center);
//        // calculate grad x
//        tmp_gx = _mm256_add_ps(
//            _mm256_mul_ps(_rot_grad_0, base_x),
//            _mm256_mul_ps(_rot_grad_1, base_y));
//        // calculate grad y
//        tmp_gy = _mm256_add_ps(
//            _mm256_mul_ps(_rot_grad_2, base_x),
//            _mm256_mul_ps(_rot_grad_3, base_y));
//        // calculate weight
//        tmp_wx = _mm256_mul_ps(mm, _mm256_mul_ps(base_x, base_x));
//        tmp_wy = _mm256_mul_ps(base_y, base_y);
//        tmp_w = _mm256_div_ps(
//            _mm256_set1_ps(m),
//            _mm256_add_ps(tmp_wx, tmp_wy));
//        // Save location x, y, gx, gy
//        _mm256_storeu_ps(sample_x + i, tmp_x);
//        _mm256_storeu_ps(sample_y + i, tmp_y);
//        _mm256_storeu_ps(grad_x + i, tmp_gx);
//        _mm256_storeu_ps(grad_y + i, tmp_gy);
//        _mm256_storeu_ps(sample_weight + i, tmp_w);
//
//    }
//
//    // Estimate the sampling points number N. Note: N = RoundEllipseCircum;
//    float step;
//    int RoundEllipseCircum = int((R + r)*CV_PI);
//    if (RoundEllipseCircum > 360) RoundEllipseCircum = 360;
//    step = 360.0 / RoundEllipseCircum;
//
//
//#if DEFINITE_ERROR_BOUNDED
//    const int Prasad_R = 10;
//    Point n;
//    double dist, min_dist;
//    Node_FC* node_center = NULL;
//#else
//    const int vld_num = _T_gradnum;
//#endif
//
//    int x, y, idxdxy, idxixy, angle_idx;
//    int xOffset, yOffset, xReal, yReal, idxdxyReal, count1, count2, length_l_i_2, length_g_i_2;
//    float w, sum_w(0), norm_li_gi, E_score(0);
//    unsigned char* _boldData = (unsigned char*)imgCanny.data;
//    Node_FC *node_temp(NULL), *node_next = NULL, *node_last = NULL;
//    Point l_i;
//    cv::Point2f g_i;
//    float inSw = 0, outSw = 0, inNum = 0, onNum = 0;
//    for (int i = 0; i < RoundEllipseCircum; i++)
//    {
//        angle_idx = round(i*step);
//        if (angle_idx >= VALIDATION_NUMBER)
//        {
//            RoundEllipseCircum = i;
//            break;
//        }
//        w = sample_weight[angle_idx];
//        //w = 1;
//        sum_w += w;
//
//        x = sample_x[angle_idx], y = sample_y[angle_idx];
//        if (OutOfRange(x, y))
//        {
//            outSw += w;
//            continue;
//        }
//        inSw += w;
//        inNum += 1;
//
//        idxdxy = dIDX(x, y), idxixy = iIDX(x, y);
//
//        if (_boldData[idxixy] == 0)
//        {
//            E_score += w * 0.5;
//            continue;
//        }
//        onNum += 1;
//        //get the real point on the edge map.
//        xOffset = _boldData[idxixy] / 10; yOffset = _boldData[idxixy] - 10 * xOffset;
//        xOffset = xOffset - 1; yOffset = yOffset - 2;
//        xReal = x - xOffset; yReal = y - yOffset;
//        idxdxyReal = dIDX(xReal, yReal);
//        // estimate the grad of this point.
//#if DEFINITE_ERROR_BOUNDED
//        node_center = data + idxdxyReal;
//
//        node_next = node_temp = node_center;
//        node_temp = node_temp->nextAddress;
//        for (count1 = 0, min_dist = 100; node_temp != NULL && count1 < Prasad_R; count1++)
//        {
//            n.x = node_temp->Location.x - node_center->Location.x;
//            n.y = node_temp->Location.y - node_center->Location.y;
//            dist = fabs(sqrt(double(n.x*n.x + n.y*n.y)) - Prasad_R);
//            //dist = abs(abs(n.x) + abs(n.y) - Prasad_R);
//            if (dist <= min_dist)
//                min_dist = dist, node_next = node_temp;
//            node_temp = node_temp->nextAddress;
//        }
//        node_last = node_temp = node_center;
//        node_temp = node_temp->lastAddress;
//        for (count2 = 0, min_dist = 100; node_temp != NULL && count2 < Prasad_R; count2++)
//        {
//            n.x = node_temp->Location.x - node_center->Location.x;
//            n.y = node_temp->Location.y - node_center->Location.y;
//            dist = fabs(sqrt(double(n.x*n.x + n.y*n.y)) - Prasad_R);
//            //dist = abs(abs(n.x) + abs(n.y) - Prasad_R);
//            if (dist <= min_dist)
//                min_dist = dist, node_last = node_temp;
//            node_temp = node_temp->lastAddress;
//        }
//        // Grad l_i Estimation
//        if (count1 + count2 + 2 < Prasad_R / 2)
//            continue;
//        l_i = node_next->Location - node_last->Location;
//#else
//        node_temp = data + idxdxyReal;
//        node_last = node_next = NULL;
//        for (count1 = 0; count1 < vld_num; count1++)
//        {
//            if (node_temp == NULL)
//                break;
//            node_next = node_temp;
//            node_temp = node_temp->nextAddress;
//            //				node_next = node_next->nextAddress;
//        }
//        node_temp = data + idxdxyReal;
//        for (count2 = 0; count2 < vld_num; count2++)
//        {
//            if (node_temp == NULL)
//                break;
//            node_last = node_temp;
//            node_temp = node_temp->lastAddress;
//        }
//        if (count1 + count2 < vld_num)
//            continue;
//        // Grad l_i Estimation
//        l_i = node_next->Location - node_last->Location;
//#endif
//        length_l_i_2 = l_i.x*l_i.x + l_i.y*l_i.y;
//        // Grad g_i Estimation
//        g_i.x = grad_x[angle_idx], g_i.y = grad_y[angle_idx];
//        length_g_i_2 = g_i.x*g_i.x + g_i.y*g_i.y;
//
//        // |g_i * l_i| / (|g_i|*|l_i|)
//        norm_li_gi = abs(l_i.x*g_i.x + l_i.y*g_i.y) / sqrt(length_l_i_2*length_g_i_2);
//        //if (norm_li_gi <= 0.707106781186548) // sqrt(2)/2 ~= 0.707106781186548
//        //	continue;
//        //E_score += w*(norm_li_gi - 0.707106781186548) / (1 - 0.707106781186548);
//        if (norm_li_gi > 1) norm_li_gi = 1;
//        E_score += w*abs(1 - 2 / CV_PI * acos(norm_li_gi));
//
//        //E_score += w;
//
//    }
//
//    if (outSw > inSw)
//        E_score = 0;
//    else
//    {
//        E_score = E_score / inSw *inNum;
//    }
//    //E_score = E_score / sum_w*RoundEllipseCircum;
//
//
//    if (E_score > inNum * _T_val)
//    {
//        *detScore = E_score / inNum;
//        return true;
//    }
//    else
//        return false;
//
//
//
//}
//*/
//
//bool FLED::fastValidation(cv::RotatedRect &res, double *detScore)
//{
//    const float angleRot(res.angle / 180 * CV_PI),
//            xyCenter[2] = {res.center.x, res.center.y},
//            R(res.size.width / 2), r(res.size.height / 2); // The major-axis and minor-axis.
//
//    // Shape constraint I_0(R,r).  Note: sqrt(2) - 1 ~= 0.414213562373095
//
//    // Shape Index
//    if (R * r * 4 < _T_min_minor * _T_min_minor)
//        return false;
//    if (R * r < 2 * _T_dp / (0.414213562373095) * sqrt(R * R + r * r))
//        return false;
//
//    const float _ROT_TRANS[4] = {R * cos(angleRot), -r * sin(angleRot), R * sin(angleRot), r * cos(angleRot)},
//            _ROT_GRAD[4] = {-r * sin(angleRot), -R * cos(angleRot), r * cos(angleRot), -R * sin(angleRot)};
//
//    float m = r / R;
//
//    if (m < 0.2)
//    {
//        detScore = 0;
//        return false;
//    } // \B3\F6\CF\D6\D4\E0\CA\FD\BEݣ\ACʹ\D3\C3\D5ⷽ\B7\A8\BD\E2\BE\F6
//    if (m < 0.4)
//        m = 0.4;
//
//#if !FASTER_ELLIPSE_VALIDATION
//    float tmpw, vldBaseData_x, vldBaseData_y, tmpx, tmpy, tmpgx, tmpgy;
//    for (int i = 0; i < VALIDATION_NUMBER; i++)
//    {
//        vldBaseData_x = vldBaseData[i][0];
//        vldBaseData_y = vldBaseData[i][1];
//        tmpw = m / (m * m * vldBaseData_x * vldBaseData_x + vldBaseData_y * vldBaseData_y);
//        tmpx = _ROT_TRANS[0] * vldBaseData_x + _ROT_TRANS[1] * vldBaseData_y + xyCenter[0];
//        tmpy = _ROT_TRANS[2] * vldBaseData_x + _ROT_TRANS[3] * vldBaseData_y + xyCenter[1];
//        tmpgx = _ROT_GRAD[0] * vldBaseData_x + _ROT_GRAD[1] * vldBaseData_y;
//        tmpgy = _ROT_GRAD[2] * vldBaseData_x + _ROT_GRAD[3] * vldBaseData_y;
//
//        sample_x[i] = tmpx;
//        sample_y[i] = tmpy;
//        grad_x[i] = tmpgx;
//        grad_y[i] = tmpgy;
//        sample_weight[i] = tmpw;
//    }
//#else
//    // Estimate the sampling points number N. Note: N = RoundEllipseCircum;
//    // Use SSE to faster the step of ellipse validation.
//    __m256 _rot_trans_0 = _mm256_set1_ps(_ROT_TRANS[0]),
//           _rot_trans_1 = _mm256_set1_ps(_ROT_TRANS[1]),
//           _rot_trans_2 = _mm256_set1_ps(_ROT_TRANS[2]),
//           _rot_trans_3 = _mm256_set1_ps(_ROT_TRANS[3]);
//
//    __m256 _rot_grad_0 = _mm256_set1_ps(_ROT_GRAD[0]),
//           _rot_grad_1 = _mm256_set1_ps(_ROT_GRAD[1]),
//           _rot_grad_2 = _mm256_set1_ps(_ROT_GRAD[2]),
//           _rot_grad_3 = _mm256_set1_ps(_ROT_GRAD[3]);
//
//    __m256 x_center = _mm256_set1_ps(xyCenter[0]),
//           y_center = _mm256_set1_ps(xyCenter[1]);
//
//    __m256 mm = _mm256_set1_ps(m * m);
//    __m256 tmp_x, tmp_y, tmp_gx, tmp_gy, tmp_wx, tmp_wy, tmp_w;
//
//    for (int i = 0; i < VALIDATION_NUMBER; i += sizeof(__m256) / sizeof(float))
//    {
//        __m256 base_x = _mm256_load_ps(vldBaseDataX + i);
//        __m256 base_y = _mm256_load_ps(vldBaseDataY + i);
//        // calculate location x
//        tmp_x = _mm256_add_ps(
//            _mm256_mul_ps(_rot_trans_0, base_x),
//            _mm256_mul_ps(_rot_trans_1, base_y));
//        tmp_x = _mm256_add_ps(tmp_x, x_center);
//        // calculate location y
//        tmp_y = _mm256_add_ps(
//            _mm256_mul_ps(_rot_trans_2, base_x),
//            _mm256_mul_ps(_rot_trans_3, base_y));
//        tmp_y = _mm256_add_ps(tmp_y, y_center);
//        // calculate grad x
//        tmp_gx = _mm256_add_ps(
//            _mm256_mul_ps(_rot_grad_0, base_x),
//            _mm256_mul_ps(_rot_grad_1, base_y));
//        // calculate grad y
//        tmp_gy = _mm256_add_ps(
//            _mm256_mul_ps(_rot_grad_2, base_x),
//            _mm256_mul_ps(_rot_grad_3, base_y));
//        // calculate weight
//        tmp_wx = _mm256_mul_ps(mm, _mm256_mul_ps(base_x, base_x));
//        tmp_wy = _mm256_mul_ps(base_y, base_y);
//        tmp_w = _mm256_div_ps(
//            _mm256_set1_ps(m),
//            _mm256_add_ps(tmp_wx, tmp_wy));
//        // Save location x, y, gx, gy
//        _mm256_storeu_ps(sample_x + i, tmp_x);
//        _mm256_storeu_ps(sample_y + i, tmp_y);
//        _mm256_storeu_ps(grad_x + i, tmp_gx);
//        _mm256_storeu_ps(grad_y + i, tmp_gy);
//        _mm256_storeu_ps(sample_weight + i, tmp_w);
//    }
//#endif
//
//    float step;
//    int RoundEllipseCircum = int((R + r) * CV_PI);
//    if (RoundEllipseCircum > 360)
//        RoundEllipseCircum = 360;
//    step = 360.0 / RoundEllipseCircum;
//
//#if DEFINITE_ERROR_BOUNDED
//    const int Prasad_R = 10;
//    Point n;
//    double dist, min_dist;
//    Node_FC *node_center = NULL;
//#else
//    const int vld_num = _T_gradnum;
//#endif
//
//    int x, y, idxdxy, idxixy, angle_idx;
//    int xOffset, yOffset, xReal, yReal, idxdxyReal, count1, count2, length_l_i_2, length_g_i_2;
//    float w, sum_w(0), norm_li_gi, E_score(0);
//    unsigned char *_boldData = (unsigned char *)imgCanny.data;
//    Node_FC *node_temp(NULL), *node_next = NULL, *node_last = NULL;
//    Point l_i;
//    cv::Point2f g_i;
//    float inSw = 0, outSw = 0, inNum = 0, onNum = 0;
//    for (int i = 0; i < RoundEllipseCircum; i++)
//    {
//        angle_idx = round(i * step);
//        if (angle_idx >= VALIDATION_NUMBER)
//        {
//            RoundEllipseCircum = i;
//            break;
//        }
//        w = sample_weight[angle_idx];
//        // w = 1;
//        sum_w += w;
//
//        x = sample_x[angle_idx], y = sample_y[angle_idx];
//        if (OutOfRange(x, y))
//        {
//            outSw += w;
//            continue;
//        }
//        inSw += w;
//        inNum += 1;
//
//        idxdxy = dIDX(x, y), idxixy = iIDX(x, y);
//
//        if (_boldData[idxixy] == 0)
//        {
//            E_score += w * 0.5;
//            continue;
//        }
//        onNum += 1;
//        //\BB\F1ȡ\D5\E6ʵ\B1\DFԵ\B5\E3
//        xOffset = _boldData[idxixy] / 10;
//        yOffset = _boldData[idxixy] - 10 * xOffset;
//        xOffset = xOffset - 1;
//        yOffset = yOffset - 2;
//        xReal = x - xOffset;
//        yReal = y - yOffset;
//        idxdxyReal = dIDX(xReal, yReal);
//        // \B9\C0\BCƵ\B1ǰ\B5\E3\B5\C4\CCݶ\C8ֵ
//#if DEFINITE_ERROR_BOUNDED
//        node_center = data + idxdxyReal;
//
//        node_next = node_temp = node_center;
//        node_temp = node_temp->nextAddress;
//        for (count1 = 0, min_dist = 100; node_temp != NULL && count1 < Prasad_R; count1++)
//        {
//            n.x = node_temp->Location.x - node_center->Location.x;
//            n.y = node_temp->Location.y - node_center->Location.y;
//            dist = fabs(sqrt(double(n.x * n.x + n.y * n.y)) - Prasad_R);
//            // dist = abs(abs(n.x) + abs(n.y) - Prasad_R);
//            if (dist <= min_dist)
//                min_dist = dist, node_next = node_temp;
//            node_temp = node_temp->nextAddress;
//        }
//        node_last = node_temp = node_center;
//        node_temp = node_temp->lastAddress;
//        for (count2 = 0, min_dist = 100; node_temp != NULL && count2 < Prasad_R; count2++)
//        {
//            n.x = node_temp->Location.x - node_center->Location.x;
//            n.y = node_temp->Location.y - node_center->Location.y;
//            dist = fabs(sqrt(double(n.x * n.x + n.y * n.y)) - Prasad_R);
//            // dist = abs(abs(n.x) + abs(n.y) - Prasad_R);
//            if (dist <= min_dist)
//                min_dist = dist, node_last = node_temp;
//            node_temp = node_temp->lastAddress;
//        }
//        // Grad l_i Estimation
//        if (count1 + count2 + 2 < Prasad_R / 2)
//            continue;
//        l_i = node_next->Location - node_last->Location;
//#else
//        node_temp = data + idxdxyReal;
//        node_last = node_next = NULL;
//        for (count1 = 0; count1 < vld_num; count1++)
//        {
//            if (node_temp == NULL)
//                break;
//            node_next = node_temp;
//            node_temp = node_temp->nextAddress;
//            //				node_next = node_next->nextAddress;
//        }
//        node_temp = data + idxdxyReal;
//        for (count2 = 0; count2 < vld_num; count2++)
//        {
//            if (node_temp == NULL)
//                break;
//            node_last = node_temp;
//            node_temp = node_temp->lastAddress;
//        }
//        if (count1 + count2 < vld_num)
//            continue;
//        // Grad l_i Estimation
//        l_i = node_next->Location - node_last->Location;
//#endif
//        length_l_i_2 = l_i.x * l_i.x + l_i.y * l_i.y;
//        // Grad g_i Estimation
//        g_i.x = grad_x[angle_idx], g_i.y = grad_y[angle_idx];
//        length_g_i_2 = g_i.x * g_i.x + g_i.y * g_i.y;
//
//        // |g_i * l_i| / (|g_i|*|l_i|)
//        norm_li_gi = abs(l_i.x * g_i.x + l_i.y * g_i.y) / sqrt(length_l_i_2 * length_g_i_2);
//        // if (norm_li_gi <= 0.707106781186548) // sqrt(2)/2 ~= 0.707106781186548
//        //	continue;
//        // E_score += w*(norm_li_gi - 0.707106781186548) / (1 - 0.707106781186548);
//        if (norm_li_gi > 1)
//            norm_li_gi = 1;
//        E_score += w * abs(1 - 2 / CV_PI * acos(norm_li_gi));
//
//        // E_score += w;
//    }
//
//    if (outSw > inSw)
//        E_score = 0;
//    else
//    {
//        E_score = E_score / inSw * inNum;
//    }
//    // E_score = E_score / sum_w*RoundEllipseCircum;
//
//    if (E_score > inNum * _T_val)
//    {
//        *detScore = E_score / inNum;
//        return true;
//    }
//    else
//        return false;
//}
//
//Node_FC::Node_FC()
//{
//    edgeID = 1;
//    nextAddress = NULL;
//    lastAddress = NULL;
//}
//
//Node_FC::Node_FC(int x, int y, int scale)
//{
//    Location.x = x;
//    Location.y = y;
//    edgeID = 1;
//    nextAddress = NULL;
//    lastAddress = NULL;
//
//    nodeMat[0] = pow(double(x), 4) / pow(scale, 4);
//    nodeMat[1] = 2 * pow(double(x), 3) * y / pow(scale, 4);
//    nodeMat[2] = double(x) * x * y * y / pow(scale, 4);
//    nodeMat[3] = 2 * pow(double(x), 3) / pow(scale, 3);
//    nodeMat[4] = 2 * double(x) * x * y / pow(scale, 3);
//    nodeMat[5] = double(x) * x / (scale * scale);
//    nodeMat[6] = 2 * double(x) * y * y * y / pow(scale, 4);
//    nodeMat[7] = 4 * double(x) * y * y / pow(scale, 3);
//    nodeMat[8] = 2 * double(x) * y / (scale * scale);
//    nodeMat[9] = pow(double(y), 4) / pow(scale, 4);
//    nodeMat[10] = 2 * pow(double(y), 3) / pow(scale, 3);
//    nodeMat[11] = double(y) * y / (scale * scale);
//    nodeMat[12] = 2 * double(x) / scale;
//    nodeMat[13] = 2 * double(y) / scale;
//    nodeMat[14] = 1;
//}
//
//bool cmp(SORTDATA &A, SORTDATA &B)
//{
//    if (A.val > B.val)
//        return true;
//    return false;
//}
//
//void EllipseNonMaximumSuppression(std::vector<cv::RotatedRect> &detElps, std::vector<double> &detEllipseScore, double T_iou)
//{
//    int elps_num = detElps.size();
//    double *_overlaps = new double[elps_num * elps_num];
//
//    // Calculate the IoUs of all ellipses
//    for (int i = 0; i < elps_num - 1; i++)
//    {
//        _overlaps[i * elps_num + i] = 0;
//        for (int j = i + 1; j < elps_num; j++)
//        {
//            _overlaps[j * elps_num + i] = _overlaps[i * elps_num + j] = EllipseOverlap(detElps[i], detElps[j]);
//        }
//    }
//
//    // cv::Mat olp(elps_num, elps_num, CV_64FC1, _overlaps);
//    // std::cout << olp << std::endl;
//    //  Get the sorted results.
//    std::vector<int> sort_idx(elps_num);
//    std::iota(sort_idx.begin(), sort_idx.end(), 0);
//    sort(sort_idx.begin(), sort_idx.end(),
//         [&detEllipseScore](int i1, int i2)
//         { return detEllipseScore[i1] > detEllipseScore[i2]; });
//
//    // NMS
//    std::vector<unsigned char> isValid(elps_num, 1);
//    std::vector<cv::RotatedRect> clusterELlipse;
//    for (int i = 0; i < elps_num; i++)
//    {
//        int select_idx = sort_idx[i];
//        if (isValid[select_idx] == 0)
//            continue;
//
//        double *_sel_overlaps = _overlaps + select_idx * elps_num;
//        for (int k = 0; k < elps_num; k++)
//        {
//            if (isValid[k] && _sel_overlaps[k] > T_iou)
//                isValid[k] = 0;
//        }
//        clusterELlipse.push_back(detElps[select_idx]);
//        isValid[select_idx] = 0;
//    }
//    detElps = clusterELlipse;
//    delete[] _overlaps;
//}
//
//// convert shape parameters to general equation parameters
//static void ELPShape2Equation(double *elpshape, double *outparms)
//{
//    double xc, yc, a, b, theta;
//    xc = elpshape[0], yc = elpshape[1], a = elpshape[2], b = elpshape[3], theta = elpshape[4];
//
//    double parm[6];
//
//    double cos_theta = cos(theta), sin_theta = sin(theta), sin_2theta = sin(2 * theta);
//    double pow_cos_theta = pow(cos_theta, 2), pow_sin_theta = pow(sin_theta, 2);
//    double aa_inv = 1 / (a * a), bb_inv = 1 / (b * b);
//    double tmp1, tmp2;
//
//    parm[0] = pow_cos_theta * aa_inv + pow_sin_theta * bb_inv;
//    parm[1] = -0.5 * sin_2theta * (bb_inv - aa_inv);
//    parm[2] = pow_cos_theta * bb_inv + pow_sin_theta * aa_inv;
//    parm[3] = (-xc * pow_sin_theta + yc * sin_2theta / 2) * bb_inv - (xc * pow_cos_theta + yc * sin_2theta / 2) * aa_inv;
//    parm[4] = (-yc * pow_cos_theta + xc * sin_2theta / 2) * bb_inv - (yc * pow_sin_theta + xc * sin_2theta / 2) * aa_inv;
//    tmp1 = (xc * cos_theta + yc * sin_theta) / a, tmp2 = (yc * cos_theta - xc * sin_theta) / b;
//    parm[5] = pow(tmp1, 2) + pow(tmp2, 2) - 1;
//
//    // parm[0] = pow(cos(theta) / a, 2) + pow(sin(theta) / b, 2);
//    // parm[1] = -(sin(2 * theta) / 2)*(pow(b, -2) - pow(a, -2));
//    // parm[2] = pow(cos(theta) / b, 2) + pow(sin(theta) / a, 2);
//    // parm[3] = (-xc*pow(sin(theta), 2) + yc*sin(2 * theta) / 2) / (b*b) - (xc*pow(cos(theta), 2) + yc*sin(2 * theta) / 2) / (a*a);
//    // parm[4] = (-yc*pow(cos(theta), 2) + xc*sin(2 * theta) / 2) / (b*b) - (yc*pow(sin(theta), 2) + xc*sin(2 * theta) / 2) / (a*a);
//    // parm[5] = pow((xc*cos(theta) + yc*sin(theta)) / a, 2) + pow((yc*cos(theta) - xc*sin(theta)) / b, 2) - 1;
//
//    double k = parm[0] * parm[2] - parm[1] * parm[1];
//    k = 1 / sqrt(abs(k));
//
//    for (int i = 0; i < 6; i++)
//        outparms[i] = parm[i] * k;
//}
//
//static bool CalculateRangeAtY(double *elpparm, double y, double *x1, double *x2)
//{
//    double A, B, C, D, E, F, t1, t2, Delta;
//    A = elpparm[0], B = elpparm[1], C = elpparm[2];
//    D = elpparm[3], E = elpparm[4], F = elpparm[5];
//
//    Delta = pow(B * y + D, 2) - A * (C * y * y + 2 * E * y + F);
//    *x1 = -10, *x2 = -20;
//    if (Delta < 0)
//        return false;
//    else
//    {
//        t1 = (-(B * y + D) - sqrt(Delta)) / A;
//        t2 = (-(B * y + D) + sqrt(Delta)) / A;
//
//        if (t2 < t1)
//            std::swap(t1, t2);
//
//        *x1 = t1;
//        *x2 = t2;
//
//        return true;
//    }
//}
//
//static void CalculateRangeOfY(double *elp_equ, double *x_min, double *x_max, double *y_min, double *y_max)
//{
//
//    double B, C;
//    B = elp_equ[1] * elp_equ[3] - elp_equ[0] * elp_equ[4];
//    C = elp_equ[3] * elp_equ[3] - elp_equ[0] * elp_equ[5];
//
//    double tx_min, tx_max, ty_min, ty_max;
//
//    ty_min = B - sqrt(B * B + C);
//    ty_max = B + sqrt(B * B + C);
//
//    tx_min = -(elp_equ[1] * ty_min + elp_equ[3]) / elp_equ[0];
//    tx_max = -(elp_equ[1] * ty_max + elp_equ[3]) / elp_equ[0];
//
//    *x_min = tx_min;
//    *x_max = tx_max;
//    *y_min = ty_min;
//    *y_max = ty_max;
//}
//
//double EllipseOverlap(cv::RotatedRect &ellipse1, cv::RotatedRect &ellipse2)
//{
//    double t1, t2;
//
//    double elp1[5], elp2[5];
//    elp1[0] = ellipse1.center.x, elp1[1] = ellipse1.center.y;
//    elp1[2] = ellipse1.size.width / 2, elp1[3] = ellipse1.size.height / 2;
//    elp1[4] = ellipse1.angle / 180 * CV_PI;
//
//    elp2[0] = ellipse2.center.x, elp2[1] = ellipse2.center.y;
//    elp2[2] = ellipse2.size.width / 2, elp2[3] = ellipse2.size.height / 2;
//    elp2[4] = ellipse2.angle / 180 * CV_PI;
//
//    // t1 = cv::getTickCount();
//    double parm1[6], parm2[6];
//    ELPShape2Equation(elp1, parm1);
//    ELPShape2Equation(elp2, parm2);
//    // t2 = cv::getTickCount();
//    double y1_min, y1_max, y2_min, y2_max, y_min, y_max, ytmp;
//    CalculateRangeOfY(parm1, &ytmp, &ytmp, &y1_min, &y1_max);
//    CalculateRangeOfY(parm2, &ytmp, &ytmp, &y2_min, &y2_max);
//
//    y_min = floor(fmax(y1_min, y2_min));
//    y_max = ceil(fmin(y1_max, y2_max));
//
//    double ration;
//
//    if (y_min >= y_max)
//    {
//        ration = 0;
//        return ration;
//    }
//
//    double max_iter = 150, min_step = 0.2, iter_step = (y_max - y_min) / (max_iter + 2);
//    double search_step = fmax(min_step, iter_step);
//
//    double S12 = 0, x11, x12, x21, x22, x_min, x_max;
//
//    // cout << "sub Use time (ms): " << (t2 - t1) * 1000 / cv::getTickFrequency() << endl;
//    for (double i = y_min; i <= y_max + 1e-6; i = i + search_step)
//    {
//        CalculateRangeAtY(parm1, i, &x11, &x12);
//        CalculateRangeAtY(parm2, i, &x21, &x22);
//
//        x_min = fmax(x11, x21), x_max = fmin(x12, x22);
//        if (x_min < x_max)
//            S12 += x_max - x_min;
//    }
//
//    ration = S12 * search_step / (CV_PI * elp1[2] * elp1[3] + CV_PI * elp2[2] * elp2[3] - S12 * search_step);
//    return ration;
//}
//
//long long int get_now()
//{
//    return chrono::duration_cast<std::chrono::milliseconds>(
//            chrono::system_clock::now().time_since_epoch())
//            .count();
//}
//
//#ifndef SCORER_H
//#define SCORER_H
//
//template <typename T>
//std::string vectorToString(const std::vector<T> &vec)
//{
//    std::ostringstream oss;
//
//    oss << "[ ";
//    if (!vec.empty())
//    {
//        // Insert the first element
//        oss << vec[0];
//        // Insert the rest of the elements with a space separator
//        for (size_t i = 1; i < vec.size(); ++i)
//        {
//            oss << " " << vec[i];
//        }
//    }
//    oss << " ]";
//    return oss.str();
//}
//
//class Scorer
//{
//private:
//    int warmup_frames;
//    float min_hit_duration;
//    cv::Ptr<cv::BackgroundSubtractorMOG2> bg_sub;
//    float last_hit_time;
//    std::vector<std::vector<cv::Point>> history;
//    std::vector<int> score_history;
//    int warmup_count;
//    int total_score;
//    int last_score;
//    cv::Point last_hit_point;
//    cv::Mat last_black_frame;
//    cv::Point p;
//
//    void _init_state();
//
//public:
//    Scorer(int warmup_frames = 5, float min_hit_duration = 1);
//    int process(cv::Mat frame, cv::Mat frame_gray, std::map<std::string, std::vector<std::pair<cv::Point, int>>> target_zone, float timestamp);
//    int get_total_score() { return total_score; }
//    int get_last_score() { return last_score; }
//    std::string get_history_as_string() { return vectorToString(score_history); }
//    int get_history_len() { return history.size(); }
//};
//
//Scorer::Scorer(int warmup_frames, float min_hit_duration)
//        : warmup_frames(warmup_frames), min_hit_duration(min_hit_duration), last_hit_time(-10000.0),
//          warmup_count(0), total_score(0), last_score(-1)
//{
//    bg_sub = cv::createBackgroundSubtractorMOG2();
//
//    _init_state();
//}
//
//void Scorer::_init_state()
//{
//    last_hit_time = -10000.0;
//    warmup_count = 0;
//    total_score = 0;
//    last_score = -1;
//    last_hit_point = cv::Point();
//    last_black_frame = cv::Mat();
//    p = cv::Point();
//}
//
//int Scorer::process(
//        cv::Mat frame,
//        cv::Mat frame_gray,
//        std::map<std::string, std::vector<std::pair<cv::Point, int>>> target_zone,
//float timestamp)
//{
//
//if (!history.empty())
//{
//cv::drawContours(frame, history, -1, cv::Scalar(0, 0, 255), 2);
//cv::drawContours(frame, std::vector<std::vector<cv::Point>>(1, history.back()), -1, cv::Scalar(222, 255, 0), 2);
//for (size_t i = 0; i < history.size(); ++i)
//{
//cv::Point min_point = *std::min_element(history[i].begin(), history[i].end(),
//                                        [](const cv::Point &lhs, const cv::Point &rhs)
//                                        {
//                                            return lhs.x < rhs.x || (lhs.x == rhs.x && lhs.y < rhs.y);
//                                        });
//cv::putText(frame, std::to_string(i + 1), min_point, cv::FONT_HERSHEY_COMPLEX, 0.7, cv::Scalar(0, 255, 0), 1);
//}
//}
//
//int frame_h = frame.rows;
//int frame_w = frame.cols;
//
//cv::Point roi_circle_center = target_zone["circles"][0].first;
//int r = target_zone["circles"][0].second;
//int padding = 20;
//
//cv::Mat safe_area_mask = cv::Mat::zeros(frame_gray.size(), CV_8UC1);
//cv::circle(safe_area_mask, roi_circle_center, r + padding, 255, -1);
//
//cv::Mat frame_hsv;
//cv::cvtColor(frame, frame_hsv, cv::COLOR_BGR2HSV);
//cv::Scalar lower_black = cv::Scalar(0, 0, 0);
//cv::Scalar upper_black = cv::Scalar(180, 255, 100);
//cv::Mat black_mask;
//cv::inRange(frame_hsv, lower_black, upper_black, black_mask);
//black_mask = black_mask & safe_area_mask;
//
//cv::Mat blur;
//cv::GaussianBlur(frame_gray, blur, cv::Size(11, 11), 0);
//cv::Mat motion;
//bg_sub->apply(blur, motion);
//
//warmup_count++;
//if (warmup_count < warmup_frames)
//{
//return -1;
//}
//
//int x1 = std::max(0, roi_circle_center.x - r);
//int y1 = std::max(0, roi_circle_center.y - r);
//int x2 = std::min(frame_w - 1, roi_circle_center.x + r);
//int y2 = std::min(frame_h - 1, roi_circle_center.y + r);
//cv::Mat crop_black_mask = black_mask(cv::Rect(x1, y1, x2 - x1, y2 - y1));
//cv::Mat new_bullet_mask;
//
//if (last_black_frame.empty())
//{
//new_bullet_mask = cv::Mat::zeros(crop_black_mask.size(), crop_black_mask.type());
//}
//else
//{
//if (last_black_frame.rows != crop_black_mask.rows || last_black_frame.cols != crop_black_mask.cols)
//{
//last_black_frame = crop_black_mask;
//return -1;
//}
//
//cv::Mat joint_mask;
//cv::bitwise_and(last_black_frame, crop_black_mask, joint_mask);
//cv::bitwise_xor(crop_black_mask, joint_mask, new_bullet_mask);
//}
//
//cv::Mat kernel;
//kernel = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(3, 3));
//cv::morphologyEx(new_bullet_mask, new_bullet_mask, cv::MORPH_OPEN, kernel);
//
//cv::dilate(new_bullet_mask, new_bullet_mask, kernel, cv::Point(-1, -1), 1);
//
//last_black_frame = crop_black_mask.clone();
//
//cv::Mat crop_motion = motion(cv::Rect(x1, y1, x2 - x1, y2 - y1));
//cv::morphologyEx(crop_motion, crop_motion, cv::MORPH_OPEN, kernel);
//
//cv::Mat joint_crop_motion;
//if (crop_motion.rows < crop_black_mask.rows || crop_motion.cols < crop_black_mask.cols)
//{
//cv::Rect crop_rect(0, 0, crop_motion.cols, crop_motion.rows);
//crop_black_mask = crop_black_mask(crop_rect);
//}
//else if (crop_motion.rows > crop_black_mask.rows || crop_motion.cols > crop_black_mask.cols)
//{
//cv::Rect crop_rect(0, 0, crop_black_mask.cols, crop_black_mask.rows);
//crop_motion = crop_motion(crop_rect);
//}
//cv::bitwise_and(crop_motion, crop_black_mask, joint_crop_motion);
//cv::bitwise_and(joint_crop_motion, new_bullet_mask, joint_crop_motion);
//
//std::vector<std::vector<cv::Point>> origin_contours;
//cv::findContours(crop_motion, origin_contours, cv::RETR_EXTERNAL, cv::CHAIN_APPROX_NONE);
//std::vector<std::vector<cv::Point>> contours;
//cv::findContours(joint_crop_motion, contours, cv::RETR_EXTERNAL, cv::CHAIN_APPROX_SIMPLE);
//
//bool time_cond = ((timestamp - last_hit_time) * 1000 > min_hit_duration * 1000);
//
//if (!contours.empty() && time_cond)
//{
//std::vector<std::vector<cv::Point>> sorted_origin_contours = origin_contours;
//std::sort(sorted_origin_contours.begin(), sorted_origin_contours.end(), [](const std::vector<cv::Point> &a, const std::vector<cv::Point> &b)
//{ return cv::contourArea(a) > cv::contourArea(b); });
//sorted_origin_contours.resize(std::min(sorted_origin_contours.size(), size_t(5)));
//
//std::vector<std::vector<cv::Point>> sorted_contours = contours;
//std::sort(sorted_contours.begin(), sorted_contours.end(), [](const std::vector<cv::Point> &a, const std::vector<cv::Point> &b)
//{ return cv::contourArea(a) > cv::contourArea(b); });
//sorted_contours.resize(std::min(sorted_contours.size(), size_t(3)));
//
//std::vector<cv::Point> &bullet_contour = sorted_contours[0];
//
//double area = cv::contourArea(bullet_contour);
//if (area > 3000)
//{
//return -1;
//}
//
//cv::Point2f center;
//float radius;
//cv::minEnclosingCircle(bullet_contour, center, radius);
//if (radius < 1.5)
//{
//return -1;
//}
//
//for (const auto &contour : sorted_origin_contours)
//{
//double result = cv::pointPolygonTest(contour, center, false);
//if (result > 0)
//{
//bullet_contour = contour;
//break;
//}
//}
//
//for (cv::Point &point : bullet_contour)
//{
//point.x += x1;
//point.y += y1;
//}
//cv::minEnclosingCircle(bullet_contour, center, radius);
//if (radius < 5)
//{
//return -1;
//}
//
//history.push_back(bullet_contour);
//last_hit_point = center;
//last_hit_time = timestamp;
//
//cv::Point roi_center_int = target_zone["circles"][0].first;
//cv::Point2f roi_center(roi_center_int.x, roi_center_int.y);
//
//std::vector<cv::Point2f> bullet_points;
//cv::Mat(bullet_contour).copyTo(bullet_points);
//
//float min_distance_to_bullseye = 1000000.0f;
//for (const auto &point : bullet_points)
//{
//float distance_to_bullseye = cv::norm(point - roi_center);
//if (distance_to_bullseye < min_distance_to_bullseye)
//{
//min_distance_to_bullseye = distance_to_bullseye;
//}
//}
//
//int score = 10;
//
//for (const auto &circle : target_zone["circles"])
//{
//if (min_distance_to_bullseye - 1 > circle.second)
//{
//score--;
//}
//}
//
//if (score < 5)
//{
//score = 0;
//}
//
//last_score = score;
//total_score += score;
//score_history.push_back(score);
//
//return score;
//}
//
//return -1;
//}
//
//#endif // SCORER_H
//
//// For Android
//#ifdef __ANDROID__
//#include <thread>
//void sleep_ms(int milliseconds)
//{
//    std::this_thread::sleep_for(std::chrono::milliseconds(milliseconds));
//}
//#endif
//
//// For iOS
//#ifdef __APPLE__
//#include <Foundation/Foundation.h>
//void sleep_ms(int milliseconds)
//{
//    [[NSRunLoop currentRunLoop] runUntilDate:[NSDate dateWithTimeIntervalSinceNow:milliseconds / 1000.0]];
//}
//#endif
//
//int readInt32FromBuffer(uint8_t *buffer)
//{
//    int32_t value = 0;
//    value |= buffer[0];
//    value |= buffer[1] << 8;
//    value |= buffer[2] << 16;
//    value |= buffer[3] << 24;
//    return value;
//}
//
//void writeInt32FromBuffer(uint8_t *buffer, int32_t value) {
//    buffer[0] = value & 0xFF;
//    buffer[1] = (value >> 8) & 0xFF;
//    buffer[2] = (value >> 16) & 0xFF;
//    buffer[3] = (value >> 24) & 0xFF;
//}
//
//// Avoiding name mangling
//extern "C"
//{
//FUNCTION_ATTRIBUTE
//const char *version()
//{
//    return CV_VERSION;
//}
//
//std::mutex mtx;
//std::mutex input_mtx;
//std::mutex last_score_mtx;
//std::mutex detect_only_mtx;
////
//std::mutex control_mtx;
//
/////Score  Backup
////
////FUNCTION_ATTRIBUTE
////        int32_t score(uint8_t *input_buffer, int platform, int _, int frame_width, int frame_height,
////        uint8_t *output_buffer, uint8_t *detect_only_buffer, char *output_path) {
////long long start = get_now();
////
////int tz_frame_width = frame_width;
////int tz_frame_height = frame_height;
////
////TargetZoneDetector tz_detector(tz_frame_height, tz_frame_width);
////Scorer scorer;
////
////int32_t prev_frame_index = -1;
////int32_t frame_index = 0;
////int32_t last_score_out = -1;
////int32_t detect_only = 1;
////
////int max_size = 1024;
////platform_log("Frame_C width: %d frame height: %d", frame_width, frame_height);
////
////uint8_t *input_buffer_ = input_buffer;
////uint8_t *output_buffer_ = output_buffer;
////uint8_t *detect_only_buffer_ = detect_only_buffer;
////is_running = true;
////int32_t fps = -1;
////
////while (is_running) {
////while (is_paused) sleep_ms(100);
////
////input_mtx.lock();
////input_buffer = input_buffer_;
////frame_index = readInt32FromBuffer(input_buffer);
////
////if (frame_index < 0 || frame_index == prev_frame_index) {
////input_mtx.unlock();
////sleep_ms(40);
////continue;
////}
////
////last_score_out = -1;
////prev_frame_index = frame_index;
////
////input_buffer += sizeof(int32_t);
////fps = readInt32FromBuffer(input_buffer);
////
////input_buffer += sizeof(int32_t);  // skip last_score
////input_buffer += sizeof(int32_t);  // skip num_bytes
////
////int n_bytes = readInt32FromBuffer(input_buffer);
////input_buffer += sizeof(int32_t);
////
////std::vector<uint8_t> tmp(input_buffer, input_buffer + n_bytes);
////if (tmp.empty()) {
////platform_log("Input buffer is empty or invalid. Skipping frame.");
////input_mtx.unlock();
////sleep_ms(40);
////continue;
////}
////
////cv::Mat frame = cv::imdecode(tmp, cv::IMREAD_UNCHANGED);
////input_mtx.unlock();
////
////if (frame.empty() || frame.cols == 0 || frame.rows == 0) {
////platform_log("Could not decode frame or frame has zero dimensions.");
////sleep_ms(40);
////continue;
////}
////
////int h = frame.rows;
////int w = frame.cols;
////
////if (w >= frame_width && h >= frame_height) {
////int pad_x = (w - frame_width) / 2;
////cv::Rect roi(pad_x, 0, frame_width, frame_height);
////frame = frame(roi);
////}
////
////double ratio = static_cast<double>(max_size) / std::max(h, w);
////if (ratio < 1) {
////int new_h = static_cast<int>(ratio * h);
////int new_w = static_cast<int>(ratio * w);
////cv::resize(frame, frame, cv::Size(new_w, new_h));
////}
////
////frame_index++;
////
////double t0 = static_cast<double>(cv::getTickCount());
////cv::Mat frame_gray;
////cv::cvtColor(frame, frame_gray, cv::COLOR_BGR2GRAY);
////
////if (!tz_detector.is_ready()) {
////tz_detector.prepare(frame, frame_gray);
////}
////
////if (!frame.empty() && !frame_gray.empty()) {
////auto numCircles = tz_detector.process(frame, frame_gray);
////if (numCircles > 0 && !tz_detector.is_shifted()) {
////auto target_zone = tz_detector.get_target_zone_info();
////
////if (target_zone.find("circles") != target_zone.end()) {
////std::vector<std::pair<cv::Point, int>> circles = target_zone["circles"];
////
////if (!circles.empty()) {
////detect_only_mtx.lock();
////detect_only = readInt32FromBuffer(detect_only_buffer);
////detect_only_mtx.unlock();
////
////if (!detect_only) {
////float timestamp = fps > 0 ? static_cast<float>(frame_index) / fps : 0;
////last_score_out = scorer.process(frame, frame_gray, target_zone, timestamp);
////} else {
////platform_log("Detect only mode enabled.");
////}
////
////for (const auto& circle : circles) {
////if (circle.second > 0) {
////platform_log("Drawing circle");
////cv::circle(frame, circle.first, circle.second, cv::Scalar(0, 255, 0), 3);
////} else {
////platform_log("Circle radius is zero or less");
////}
////}
////} else {
////platform_log("No circles found.");
////}
////} else {
////platform_log("Target zone missing 'circles' key.");
////}
////} else {
////platform_log("No valid target zone found or shifted.");
////}
////} else {
////platform_log("Invalid frame or grayscale frame.");
////}
////
////// Draw FPS overlay
////double t1 = static_cast<double>(cv::getTickCount());
////int runningFps = cvRound(cv::getTickFrequency() / (t1 - t0));
////std::string text = "#frame " + std::to_string(frame_index) + " fps: " + std::to_string(runningFps);
////cv::putText(frame, text, cv::Point(50, 50), cv::FONT_HERSHEY_COMPLEX, 0.7, cv::Scalar(0, 255, 0), 1, cv::LINE_AA);
////
////// Resize to original if needed
////if (ratio < 1) {
////cv::resize(frame, frame, cv::Size(frame_width, frame_height));
////}
////
////// ✅ Always encode and write output — even in detect-only mode
////mtx.lock();
////output_buffer = output_buffer_;
////
////std::memcpy(output_buffer, &frame_index, sizeof(int32_t));
////output_buffer += sizeof(int32_t);
////
////std::memcpy(output_buffer, &fps, sizeof(int32_t));
////output_buffer += sizeof(int32_t);
////
////int32_t tmp_last_score = detect_only ? -1 : last_score_out;
////std::memcpy(output_buffer, &tmp_last_score, sizeof(int32_t));
////output_buffer += sizeof(int32_t);
////
////std::vector<uchar> encoded_image_bytes;
////cv::imencode(".png", frame, encoded_image_bytes);
////
////int32_t frame_bytes = encoded_image_bytes.size();
////std::memcpy(output_buffer, &frame_bytes, sizeof(int32_t));
////output_buffer += sizeof(int32_t);
////
////std::memcpy(output_buffer, encoded_image_bytes.data(), frame_bytes);
////mtx.unlock();
////}
////
////platform_log("Processing done in %dms", static_cast<int>(get_now() - start));
////is_running = false;
////return 0;
////}
//
//
/////Testing
//FUNCTION_ATTRIBUTE
//        int32_t score(uint8_t *input_buffer, int platform, int _, int frame_width, int frame_height,
//        uint8_t *output_buffer, uint8_t *detect_only_buffer, char *output_path) {
//long long start = get_now();
//
//int tz_frame_width = frame_width;
//int tz_frame_height = frame_height;
//
//TargetZoneDetector tz_detector(tz_frame_height, tz_frame_width);
//Scorer scorer;
//
//int32_t prev_frame_index = -1;
//int32_t frame_index = 0;
//int32_t last_score_out = -1;
//int32_t detect_only = 1;  // flag: 1 means "detect-only" mode
//
//int max_size = 1024;
//platform_log("Frame_C width: %d frame height: %d", frame_width, frame_height);
//platform_log("Frame_type : %d", input_buffer);
//
//uint8_t *input_buffer_ = input_buffer;
//uint8_t *output_buffer_ = output_buffer;
//uint8_t *detect_only_buffer_ = detect_only_buffer;
//is_running = true;
//int32_t fps = -1;
//
//// Variable to hold the number of detected circles
//int circleCount = 0;
//
//while (is_running) {
//while (is_paused)
//sleep_ms(100);
//
//input_mtx.lock();
//input_buffer = input_buffer_;
//frame_index = readInt32FromBuffer(input_buffer);
//
//if (frame_index < 0 || frame_index == prev_frame_index) {
//input_mtx.unlock();
//sleep_ms(40);
//continue;
//}
//
//last_score_out = -1;
//prev_frame_index = frame_index;
//
//input_buffer += sizeof(int32_t);
//fps = readInt32FromBuffer(input_buffer);
//
//input_buffer += sizeof(int32_t);  // skip last_score field
//input_buffer += sizeof(int32_t);  // skip num_bytes field
//
//int n_bytes = readInt32FromBuffer(input_buffer);
//input_buffer += sizeof(int32_t);
//
//std::vector<uint8_t> tmp(input_buffer, input_buffer + n_bytes);
//if (tmp.empty()) {
//platform_log("Input buffer is empty or invalid. Skipping frame.");
//input_mtx.unlock();
//sleep_ms(40);
//continue;
//}
//
//cv::Mat frame = cv::imdecode(tmp, cv::IMREAD_UNCHANGED);
//input_mtx.unlock();
//
//if (frame.empty() || frame.cols == 0 || frame.rows == 0) {
//platform_log("Could not decode frame or frame has zero dimensions.");
//sleep_ms(40);
//continue;
//}
//
//int h = frame.rows;
//int w = frame.cols;
//
//if (w >= frame_width && h >= frame_height) {
//int pad_x = (w - frame_width) / 2;
//cv::Rect roi(pad_x, 0, frame_width, frame_height);
//frame = frame(roi);
//}
//
//double ratio = static_cast<double>(max_size) / std::max(h, w);
//if (ratio < 1) {
//int new_h = static_cast<int>(ratio * h);
//int new_w = static_cast<int>(ratio * w);
//cv::resize(frame, frame, cv::Size(new_w, new_h));
//}
//
//frame_index++;
//
//double t0 = static_cast<double>(cv::getTickCount());
//cv::Mat frame_gray;
//cv::cvtColor(frame, frame_gray, cv::COLOR_BGR2GRAY);
//
//if (!tz_detector.is_ready()) {
//tz_detector.prepare(frame, frame_gray);
//}
//
//if (!frame.empty() && !frame_gray.empty()) {
//auto numCircles = tz_detector.process(frame, frame_gray);
//if (numCircles > 0 && !tz_detector.is_shifted()) {
//auto target_zone = tz_detector.get_target_zone_info();
//
//if (target_zone.find("circles") != target_zone.end()) {
//std::vector<std::pair<cv::Point, int>> circles = target_zone["circles"];
//// Update circle count with number of detected circles.
//circleCount = static_cast<int>(circles.size());
//
//if (!circles.empty()) {
//detect_only_mtx.lock();
//detect_only = readInt32FromBuffer(detect_only_buffer);
//detect_only_mtx.unlock();
//
//if (!detect_only) {
//float timestamp = fps > 0 ? static_cast<float>(frame_index) / fps : 0;
//last_score_out = scorer.process(frame, frame_gray, target_zone, timestamp);
//} else {
//platform_log("Detect only mode enabled.");
//}
//
//for (const auto& circle : circles) {
//if (circle.second > 0) {
//platform_log("Drawing circle");
//// 1) build your palette in BGR order
////static const std::vector<cv::Scalar> palette = {
////        {  0, 255,   0}, // green
////        {  0, 165, 255}, // orange
////        {255,   0,   0}, // pure blue
////        {  0, 255, 255}, // bright yellow
////        {255, 255,   0}, // cyan
////        {255,   0, 255}, // magenta
////        {  0,   0,   0}, // black
////        {  0, 255,   0}, // bright green (same as first if you like)
////        {  0, 128,   0}, // dark green
////        {128,   0,   0}, // navy blue
////        {128, 128,   0}, // teal
////        {128,   0, 128}, // purple
////        { 42,  42, 165}, // brown
////        {  0, 128, 128}  // olive
////};
////
////// 2) pick the index
////int segment = frame_index / 400;
////if (segment >= (int)palette.size())
////segment = (int)palette.size() - 1;
////
////// 3) draw using the selected color
////cv::Scalar color = palette[segment];
////cv::circle(frame, circle.first, circle.second, color, 3);
//
//
////green
////cv::circle(frame, circle.first, circle.second, cv::Scalar(0, 255, 0), 2);
////orange
//
////cv::circle(frame, circle.first, circle.second, cv::Scalar(0, 165, 255), 3);
//// Pure blue
//cv::circle(frame, circle.first, circle.second, cv::Scalar(255, 0,   0), 2);
//
//// Bright yellow
////cv::circle(frame, circle.first, circle.second, cv::Scalar(  0, 255, 255), 3);
//
//// Cyan (turquoise)
////cv::circle(frame, circle.first, circle.second, cv::Scalar(255, 255,   0), 3);
//
//// Magenta (pinkish — avoids pure red)
////cv::circle(frame, circle.first, circle.second, cv::Scalar(255,   0, 255), 3);
//
//// Black (max contrast)
////cv::circle(frame, circle.first, circle.second, cv::Scalar(  0,   0,   0), 3);
//
//// Bright green
////cv::circle(frame, circle.first, circle.second, cv::Scalar(0, 255,   0), 3);
//
//// Dark green
////cv::circle(frame, circle.first, circle.second, cv::Scalar(0, 128,   0), 3);
//
//// Navy blue
////cv::circle(frame, circle.first, circle.second, cv::Scalar(128,   0,   0), 3);
//
//// Teal (dark cyan)
////cv::circle(frame, circle.first, circle.second, cv::Scalar(128, 128,   0), 3);
//
//// Purple
////cv::circle(frame, circle.first, circle.second, cv::Scalar(128,   0, 128), 3);
//
//// Brown
//// (approx RGB 165,42,42 → BGR (42,42,165))
////cv::circle(frame, circle.first, circle.second, cv::Scalar( 42,  42, 165), 3);
//
//// Olive
//// (mix of green+red but darker: RGB 128,128,0 → BGR (0,128,128))
////cv::circle(frame, circle.first, circle.second, cv::Scalar(  0, 128, 128), 3);
//
//
//
//
//} else {
//platform_log("Circle radius is zero or less");
//}
//}
//} else {
//platform_log("No circles found.");
//}
//} else {
//platform_log("Target zone missing 'circles' key.");
//}
//} else {
//platform_log("No valid target zone found or shifted.");
//}
//} else {
//platform_log("Invalid frame or grayscale frame.");
//}
//
//double t1 = static_cast<double>(cv::getTickCount());
//int runningFps = cvRound(cv::getTickFrequency() / (t1 - t0));
//std::string text = "#frame " + std::to_string(frame_index) + " fps: " + std::to_string(runningFps);
//cv::putText(frame, text, cv::Point(50, 50), cv::FONT_HERSHEY_COMPLEX, 0.7, cv::Scalar(0, 255, 0), 1, cv::LINE_AA);
//
//if (ratio < 1) {
//cv::resize(frame, frame, cv::Size(frame_width, frame_height));
//}
//
//// Always encode and write output — even in detect-only mode
//mtx.lock();
//output_buffer = output_buffer_;
//
//// Write frame index and fps
//std::memcpy(output_buffer, &frame_index, sizeof(int32_t));
//output_buffer += sizeof(int32_t);
//std::memcpy(output_buffer, &fps, sizeof(int32_t));
//output_buffer += sizeof(int32_t);
//
//// In detect-only mode, return the number of detected circles; otherwise, return the computed score.
//int32_t tmp_last_score = detect_only ? static_cast<int32_t>(circleCount) : last_score_out;
//std::memcpy(output_buffer, &tmp_last_score, sizeof(int32_t));
//output_buffer += sizeof(int32_t);
//
//std::vector<uchar> encoded_image_bytes;
//cv::imencode(".png", frame, encoded_image_bytes);
//
//int32_t frame_bytes = encoded_image_bytes.size();
//std::memcpy(output_buffer, &frame_bytes, sizeof(int32_t));
//output_buffer += sizeof(int32_t);
//std::memcpy(output_buffer, encoded_image_bytes.data(), frame_bytes);
//mtx.unlock();
//}
//
//platform_log("Processing done in %dms", static_cast<int>(get_now() - start));
//is_running = false;
//return 0;
//}
//
/////new testing dublicate shots issues
////FUNCTION_ATTRIBUTE
////        int32_t score(uint8_t *input_buffer, int platform, int /*unused*/, int frame_width, int frame_height,
////        uint8_t *output_buffer, uint8_t *detect_only_buffer, char * /*output_path*/)
////{
////long long start = get_now();
////
////// Prepare detector & scorer
////TargetZoneDetector tz_detector(frame_height, frame_width);
////Scorer scorer;
////
////// State vars
////int32_t prev_frame_index = -1;
////int32_t frame_index      = 0;
////int32_t last_score_out   = -1;
////int32_t detect_only      = 1;      // 1 = detect-only mode
////int     max_size         = 1024;
////int32_t fps              = -1;
////int     circleCount      = 0;
////
////platform_log("Frame_C width: %d height: %d", frame_width, frame_height);
////platform_log("Frame_type : %p", input_buffer);
////
////// Keep originals so we can reposition the pointers each loop
////uint8_t *inBuf  = input_buffer;
////uint8_t *outBuf = output_buffer;
////uint8_t *detBuf = detect_only_buffer;
////
////is_running = true;
////while (is_running) {
////// pause support
////while (is_paused) sleep_ms(100);
////
////// --- READ ONE PACKET FROM INPUT ---
////input_mtx.lock();
////input_buffer = inBuf;
////
////// 1) read frame_index header
////frame_index = readInt32FromBuffer(input_buffer);
////if (frame_index < 0 || frame_index == prev_frame_index) {
////input_mtx.unlock();
////sleep_ms(40);
////continue;
////}
////prev_frame_index = frame_index;
////
////// 2) read FPS
////input_buffer += sizeof(int32_t);
////fps = readInt32FromBuffer(input_buffer);
////
////// 3) skip old-score and old-byteCount headers
////input_buffer += sizeof(int32_t);  // skip last_score field
////input_buffer += sizeof(int32_t);  // skip num_bytes field
////
////// 4) read payload size and extract image bytes
////int32_t n_bytes = readInt32FromBuffer(input_buffer);
////input_buffer += sizeof(int32_t);
////std::vector<uint8_t> rawImg(input_buffer, input_buffer + n_bytes);
////input_mtx.unlock();
////
////if (rawImg.empty()) {
////platform_log("Input buffer empty, skipping frame.");
////sleep_ms(40);
////continue;
////}
////
////// decode image
////cv::Mat frame = cv::imdecode(rawImg, cv::IMREAD_UNCHANGED);
////if (frame.empty()) {
////platform_log("Decode failed or zero-dim frame.");
////sleep_ms(40);
////continue;
////}
////
////// center-crop & resize to match expected dimensions
////int h = frame.rows, w = frame.cols;
////if (w >= frame_width && h >= frame_height) {
////int pad_x = (w - frame_width)/2;
////frame = frame(cv::Rect(pad_x, 0, frame_width, frame_height));
////}
////double ratio = double(max_size)/std::max(h, w);
////if (ratio < 1.0) {
////cv::resize(frame, frame, cv::Size(int(ratio*w), int(ratio*h)));
////}
////
////// bump our internal counter
////frame_index++;
////
////// convert & detect
////double t0 = cv::getTickCount();
////cv::Mat gray;
////cv::cvtColor(frame, gray, cv::COLOR_BGR2GRAY);
////if (!tz_detector.is_ready()) {
////tz_detector.prepare(frame, gray);
////}
////auto numCircles = tz_detector.process(frame, gray);
////if (numCircles > 0 && !tz_detector.is_shifted()) {
////auto zone = tz_detector.get_target_zone_info();
////if (zone.count("circles")) {
////circleCount = int(zone["circles"].size());
////
////// read detect-only flag
////detect_only_mtx.lock();
////detect_only = readInt32FromBuffer(detBuf);
////detect_only_mtx.unlock();
////
////if (!detect_only) {
////float timestamp = fps > 0 ? float(frame_index)/fps : 0.0f;
////last_score_out = scorer.process(frame, gray, zone, timestamp);
////} else {
////platform_log("Detect only mode enabled.");
////}
////
////// draw each circle
////for (auto &c : zone["circles"]) {
////if (c.second > 0) {
////cv::circle(frame, c.first, c.second, cv::Scalar(255,0,0), 2);
////}
////}
////}
////}
////double t1 = static_cast<double>(cv::getTickCount());
////int runningFps = cvRound(cv::getTickFrequency() / (t1 - t0));
//////double t1 = static_cast<double>(cv::getTickCount());
//////double fpsVal = cv::getTickFrequency() / (t1 - t0);
//////int runningFps = static_cast<int>(std::lround(fpsVal));
////std::string txt = "#frame " + std::to_string(frame_index)
////                  + " fps: "     + std::to_string(runningFps);
////cv::putText(frame, txt, cv::Point(50,50),
////        cv::FONT_HERSHEY_COMPLEX, 0.7,
////cv::Scalar(0,255,0), 1, cv::LINE_AA);
////
////if (ratio < 1.0) {
////cv::resize(frame, frame, cv::Size(frame_width, frame_height));
////}
////
////// re-encode to PNG
////std::vector<uchar> encoded;
////cv::imencode(".png", frame, encoded);
////
////// --- BUILD ATOMIC OUTPUT PACKET ---
////std::vector<uint8_t> packet;
////packet.reserve(4 + 4 + 4 + 4 + encoded.size());
////
////// placeholder for frame_index
////packet.insert(packet.end(), sizeof(int32_t), 0);
////
////// helper to append 32-bit values
////auto put32 = [&](int32_t v) {
////    uint8_t *p = reinterpret_cast<uint8_t*>(&v);
////    packet.insert(packet.end(), p, p + sizeof(v));
////};
////
////put32(fps);
////put32(detect_only ? circleCount : last_score_out);
////put32(int32_t(encoded.size()));
////packet.insert(packet.end(), encoded.begin(), encoded.end());
////
////// write real frame_index at front
////std::memcpy(packet.data(), &frame_index, sizeof(int32_t));
////
////// copy in one go
////mtx.lock();
////std::memcpy(outBuf, packet.data(), packet.size());
////mtx.unlock();
////}
////
////platform_log("Processing done in %dms", int(get_now()-start));
////is_running = false;
////return 0;
////}
//
//
//
//
/////check_
////FUNCTION_ATTRIBUTE
////        int32_t score(uint8_t *input_buffer, int platform, int _, int frame_width, int frame_height, uint8_t *output_buffer, uint8_t *detect_only_buffer, char *output_path) {
////long long start = get_now();
////
////int tz_frame_width, tz_frame_height;
////tz_frame_height = frame_height;
////tz_frame_width = frame_width;
////
////TargetZoneDetector tz_detector(tz_frame_height, tz_frame_width);
////Scorer scorer;
////
////int32_t prev_frame_index = -1;
////int32_t frame_index = 0;
////int32_t last_score_out = -1;
////int32_t detect_only = 1;
////
////int max_size = 1024;
////platform_log("Frame width: %d frame height: %d\n", frame_width, frame_height);
////platform_log("Frame width: %d frame height: %d\n", frame_width, frame_height);
////
////uint8_t *input_buffer_ = input_buffer;
////uint8_t *output_buffer_ = output_buffer;
////is_running = true;
////int32_t fps = -1;
////
////while (true) {
////// Stop signal
////if (!is_running) break;
////
////std::unique_lock<std::mutex> lock(input_mtx, std::try_to_lock);
////if (!lock.owns_lock()) {
////std::this_thread::yield(); // Yield CPU and try again
////continue;
////}
////
////input_buffer = input_buffer_;
////frame_index = readInt32FromBuffer(input_buffer);
////if (frame_index < 0 || frame_index == prev_frame_index) {
////input_mtx.unlock();
////std::this_thread::yield();  // Yield CPU instead of sleeping
////
////continue;
////}
////
////last_score_out = -1;
////prev_frame_index = frame_index;
////
////// Read fps
////input_buffer += sizeof(int32_t);
////fps = readInt32FromBuffer(input_buffer);
////
////// read last_score
////input_buffer += sizeof(int32_t);
////int32_t last_score_ = readInt32FromBuffer(input_buffer);  // ignore
////
////// read num_bytes
////input_buffer += sizeof(int32_t);
////int n_bytes = readInt32FromBuffer(input_buffer);
////
////input_buffer += sizeof(int32_t);
////cv::Mat frame;
////std::vector<uint8_t> tmp(input_buffer, input_buffer + n_bytes);
////frame = cv::imdecode(tmp, cv::IMREAD_UNCHANGED);
////
////if (frame.empty()) {
////platform_log("Could not decode frame\n");
////input_mtx.unlock();
////sleep_ms(10);
////continue;
////}
////
////input_mtx.unlock();
////
////if (frame.empty()) {
////break;
////}
////
////int h = frame.rows;
////int w = frame.cols;
////if (w > frame_width) {
////int pad_x = (w - frame_width) / 2;
////cv::Rect roi(pad_x, 0, frame_width, frame_height);
////frame = frame(roi);
////}
////double ratio = static_cast<double>(max_size) / std::max(h, w);
////if (ratio < 1) {
////int new_h = static_cast<int>(ratio * h);
////int new_w = static_cast<int>(ratio * w);
////cv::resize(frame, frame, cv::Size(new_w, new_h));
////}
////
////frame_index++;
////
////double t0 = static_cast<double>(cv::getTickCount());
////cv::Mat frame_gray;
////cv::cvtColor(frame, frame_gray, cv::COLOR_BGR2GRAY);
////
////if (!tz_detector.is_ready()) {
////tz_detector.prepare(frame, frame_gray);
////} else {
////if (frame.empty() || frame_gray.empty()) {
////platform_log("invalid frame");
////} else {
////auto numCircles = tz_detector.process(frame, frame_gray);
////
////if (numCircles > 0 && !tz_detector.is_shifted()) {
////auto target_zone = tz_detector.get_target_zone_info();
////std::vector<std::pair<cv::Point, int>> circles = target_zone["circles"];
////
////if (!circles.empty()) {
////platform_log("Number of circles: %d fps: %d frame_index %d frame_width %d frame_height: %d", circles.size(), fps, frame_index, frame_width, frame_height);
////
////// Safely access shared data using mutex
////platform_log("Locking detect_only_mtx");
////detect_only_mtx.lock();
////detect_only = readInt32FromBuffer(detect_only_buffer);
////platform_log("Unlocking detect_only_mtx");
////detect_only_mtx.unlock();
////
////if (!detect_only) {
////float timestamp = static_cast<float>(frame_index) / fps;
////last_score_out = scorer.process(frame, frame_gray, target_zone, timestamp);
////}
////
////for (const auto &circle : circles) {
////if (circle.second > 0) {
////cv::circle(frame, circle.first, circle.second, cv::Scalar(255, 255, 255), 2);
////}
////}
////}
////}
////}
////}
////
////int total_score = scorer.get_total_score();
////int last_score = scorer.get_last_score();
////
////double t1 = static_cast<double>(cv::getTickCount());
////int runningFps = cvRound(cv::getTickFrequency() / (t1 - t0));
////
////std::string last_score_txt = "last score: " + (last_score < 0 ? "_" : std::to_string(last_score));
////std::string text = "#frame " + std::to_string(frame_index) + " fps: " + std::to_string(runningFps) + " " + last_score_txt + " total score: " + std::to_string(total_score);
////std::string history_text = scorer.get_history_as_string();
////cv::putText(frame, text, cv::Point(50, 50), cv::FONT_HERSHEY_COMPLEX, 0.7, cv::Scalar(0, 255, 0), 1, cv::LINE_AA);
////cv::putText(frame, history_text, cv::Point(50, 100), cv::FONT_HERSHEY_COMPLEX, 0.7, cv::Scalar(0, 255, 0), 1, cv::LINE_AA);
////
////if (ratio < 1) {
////cv::resize(frame, frame, cv::Size(frame_width, frame_height));
////}
////
////// |frame_index|FPS|num_bytes|frame_bytes|
////mtx.lock();
////output_buffer = output_buffer_;
////
////// frame_index
////std::memcpy(output_buffer, &frame_index, sizeof(int32_t));
////output_buffer += sizeof(int32_t);
////
////// FPS
////std::memcpy(output_buffer, &fps, sizeof(int32_t));
////output_buffer += sizeof(int32_t);
////
////int32_t tmp_last_score = last_score_out;
////std::memcpy(output_buffer, &tmp_last_score, sizeof(int32_t));
////output_buffer += sizeof(int32_t);
////
////// num_bytes + frame_bytes
////std::vector<uchar> encoded_image_bytes;
////cv::imencode(".png", frame, encoded_image_bytes);
////
////// num_bytes
////int32_t frame_bytes = encoded_image_bytes.size();
////std::memcpy(output_buffer, &frame_bytes, sizeof(int32_t));
////output_buffer += sizeof(int32_t);
////
////// frame_bytes
////std::memcpy(output_buffer, encoded_image_bytes.data(), frame_bytes);
////
////mtx.unlock();
////}
////
////platform_log("total frames: %d\n", frame_index);
////int evalInMillis = static_cast<int>(get_now() - start);
////platform_log("Processing done in %dms\n", evalInMillis);
////
////is_running = false;
////return 0;
////}
//
//
//FUNCTION_ATTRIBUTE
//void lock()
//{
//    mtx.lock();
//}
//
//FUNCTION_ATTRIBUTE
//void unlock()
//{
//    mtx.unlock();
//}
//
//FUNCTION_ATTRIBUTE
//void inputLock()
//{
//    input_mtx.lock();
//}
//
//FUNCTION_ATTRIBUTE
//void inputUnlock()
//{
//    input_mtx.unlock();
//}
//
//FUNCTION_ATTRIBUTE
//void detectOnlyLock()
//{
//    detect_only_mtx.lock();
//}
//
//FUNCTION_ATTRIBUTE
//void detectOnlyUnlock()
//{
//    detect_only_mtx.unlock();
//}
//
//
//FUNCTION_ATTRIBUTE
//void lastScoreLock()
//{
//    last_score_mtx.lock();
//}
//
//FUNCTION_ATTRIBUTE
//void lastScoreUnlock()
//{
//    last_score_mtx.unlock();
//}
//
//FUNCTION_ATTRIBUTE
//void pause() {
//    std::lock_guard<std::mutex> lock(control_mtx);
//    is_paused = true;
//}
//
//FUNCTION_ATTRIBUTE
//void resume() {
//    std::lock_guard<std::mutex> lock(control_mtx);
//    is_paused = false;
//}
//
//FUNCTION_ATTRIBUTE
//void stop(){
//    is_running = false;
//}
//
//}
//



/////Current_COde 8/Jul

//FUNCTION_ATTRIBUTE
//int32_t score(uint8_t *input_buffer, int platform, int _, int frame_width, int frame_height,
//              uint8_t *output_buffer, uint8_t *detect_only_buffer, char *output_path)
//{
//
//    struct PersistentShot {
//        cv::Point display_point;
//        int shot_number;
//        int score;
//    };
//
//    static std::vector<PersistentShot> session_history;
//
//
//    // Reset history on first call or when explicitly needed
//    if (!session_started) {
//        session_history.clear();
//        global_shot_counter = 0;
//        session_started = true;
//        platform_log("Session history initialized");
//    }
//
//    // ========================================================================
//    // HELPER FUNCTIONS (LOCAL TO THIS FUNCTION)
//    // ========================================================================
//    auto capture_shot = [&](Scorer& scorer,
//                            const cv::Mat& frame,
//                            const cv::Point& offset) {
//        const auto& scorer_history = scorer.get_history();
//        if (scorer_history.empty()) return;
//
//        const auto& latest_contour = scorer_history.back();
//        if (latest_contour.empty()) return;
//
//        // Find display point (for storing in session_history)
//        cv::Point min_point = *std::min_element(
//                latest_contour.begin(), latest_contour.end(),
//                [](const cv::Point &a, const cv::Point &b) {
//                    return a.x < b.x || (a.x == b.x && a.y < b.y);
//                });
//
//        PersistentShot shot;
//        shot.display_point = min_point;
//        shot.shot_number   = ++global_shot_counter;
//        shot.score         = scorer.get_last_score();
//        session_history.push_back(shot);
//
//        if (is_ble) {
//            // Clone frame and draw rings around the actual contour
//            cv::Mat screenshot = frame.clone();
//
//            // 1) Compute enclosing circle of the latest contour
//            cv::Point2f center_f;
//            float radius = 0.f;
//            cv::minEnclosingCircle(latest_contour, center_f, radius);
//
//            // 2) Apply offset and convert to integer point
//            cv::Point center_i(
//                    static_cast<int>(center_f.x + offset.x),
//                    static_cast<int>(center_f.y + offset.y)
//            );
//
//            // 3) Draw inner ring (color based on score)
//            cv::Scalar innerColor = cv::Scalar(0, 0, 255); // green hit
//                                     // red miss
//            cv::circle(
//                    screenshot,
//                    center_i,
//                    static_cast<int>(radius + 8),
//                    innerColor,
//                    6
//            );
//
//            // 4) Draw outer black ring
//            cv::circle(
//                    screenshot,
//                    center_i,
//                    static_cast<int>(radius + 18),
//                    cv::Scalar(0, 0, 0),
//                    5
//            );
//
//            // 5) Encode & flag screenshot
//            cv::imencode(".png", screenshot, g_screenshot_data);
//            g_has_new_screenshot    = true;
//            g_screenshot_shot_number = shot.shot_number;
//            platform_log(":camera: Shot #%d captured with screenshot", shot.shot_number);
//        } else {
//            platform_log("Shot #%d captured (Score: %d)", shot.shot_number, shot.score);
//        }
//    };
//
////    auto capture_shot = [&](Scorer& scorer, const cv::Mat& frame, const cv::Point& offset) {
////        const auto& scorer_history = scorer.get_history();
////        if (scorer_history.empty()) return;
////
////        const auto& latest_contour = scorer_history.back();
////        if (latest_contour.empty()) return;
////
////        // Find display point
////        cv::Point min_point = *std::min_element(latest_contour.begin(), latest_contour.end(),
////                                                [](const cv::Point &lhs, const cv::Point &rhs) {
////                                                    return lhs.x < rhs.x || (lhs.x == rhs.x && lhs.y < rhs.y);
////                                                });
////
////        PersistentShot shot;
////        shot.display_point = min_point;
////        shot.shot_number = ++global_shot_counter;
////        shot.score = scorer.get_last_score();
////
////        session_history.push_back(shot);
////
////        // NEW - ADD screenshot creation if BLE active:
////        if (is_ble) {
////            cv::Mat screenshot = frame.clone();
////            cv::Point pos = shot.display_point + offset;
////            cv::Scalar color = shot.score > 0 ? cv::Scalar(0, 255, 0) : cv::Scalar(0, 0, 255);
////            cv::putText(screenshot, std::to_string(shot.shot_number), pos,
////                        cv::FONT_HERSHEY_COMPLEX, 0.7, color, 2);
////
////            cv::imencode(".png", screenshot, g_screenshot_data);
////            g_has_new_screenshot = true;
////            g_screenshot_shot_number = shot.shot_number;
////            platform_log(":camera: Shot #%d captured with screenshot", shot.shot_number);
////        } else {
////            platform_log("Shot #%d captured (Score: %d)", shot.shot_number, shot.score);
////        }
////    };
//
////    auto draw_history = [&](cv::Mat& frame, const cv::Point& offset = cv::Point(0,0)) {
////        for (const auto& shot : session_history) {
////            cv::Point display_pos = shot.display_point + offset;
////            cv::Scalar color = shot.score > 0 ? cv::Scalar(0, 255, 0) : cv::Scalar(0, 0, 255);
////            cv::putText(frame, std::to_string(shot.shot_number), display_pos,
////                        cv::FONT_HERSHEY_COMPLEX, 0.7, color, 2);
////        }
////    };
//    auto draw_history = [&](cv::Mat& frame, const cv::Point& offset = cv::Point(0,0)) {
//        // Radii & thickness
//        constexpr int INNER_RADIUS = 15;
//        constexpr int OUTER_RADIUS = 25;
//        constexpr int INNER_THICK  = 4;
//        constexpr int OUTER_THICK  = 3;
//
//        size_t total = session_history.size();
//        if (total == 0) return;
//
//        for (size_t i = 0; i < total; ++i) {
//            const auto& shot = session_history[i];
//            cv::Point center = shot.display_point + offset;
//
//            // Inner ring color: green for hit, red for miss
//            cv::Scalar innerColor =  cv::Scalar(0,   0, 255);
//
//            // Draw only the inner ring for every shot
//            cv::circle(
//                    frame,
//                    center,
//                    INNER_RADIUS,
//                    innerColor,
//                    INNER_THICK
//            );
//
//            // If this is the latest shot, add the black outer ring
//            if (i == total - 1) {
//                cv::circle(
//                        frame,
//                        center,
//                        OUTER_RADIUS,
//                        cv::Scalar(0, 0, 0),
//                        OUTER_THICK
//                );
//            }
//        }
//    };
//
//
//    long long start = get_now();
//    int tz_frame_width = frame_width;
//    int tz_frame_height = frame_height;
//    TargetZoneDetector tz_detector(tz_frame_height, tz_frame_width);
//    TargetZoneDetector calibration_detector(tz_frame_height, tz_frame_width, 1);
//    Scorer scorer;
//    int32_t prev_frame_index = -1;
//    int32_t frame_index = 0;
//    int32_t last_score_out = -1;
//    int32_t detect_only = 1;
//    int max_size = 1024;
//    platform_log("Frame_C width: %d frame height: %d", frame_width, frame_height);
//    platform_log("Frame_type : %d", input_buffer);
//    uint8_t *input_base = input_buffer;
//    uint8_t *output_base = output_buffer;
//    uint8_t *detect_only_base = detect_only_buffer;
//    is_running = true;
//    is_paused = false;
//    is_ble = false;
//    global_shot_counter = 0;
//    g_screenshot_data.clear();
//    g_has_new_screenshot = false;
//    g_screenshot_shot_number = 0;
//
//    session_started = false;
//    int32_t fps = -1;
//    int circleCount = 0;
//    setup_valid = false;
//    geometry_fixed = false;
//    roi_initialized = false;
//    calibration_check_counter = 0;
//    last_detected_ellipses.clear();
//
//    ///For_Logs
//    clearList();
//    int fontFace   = cv::FONT_HERSHEY_COMPLEX;
//    double fontScale = 0.7;
//    int thickness  = 1;
//    int baseline   = 0;
//// compute line height
//    cv::Size ts = cv::getTextSize("M", fontFace, fontScale, thickness, &baseline);
//    int lineHeight = ts.height + baseline + 5;
//// starting position
//    int x  = 5;
//    int y0 = 50;
//    ///End_Logs
//
//    while (is_running)
//    {
//        // pause handling
//        while (is_paused)
//            sleep_ms(100);
//        input_mtx.lock();
//        input_buffer = input_base;
//        int32_t raw_idx = readInt32FromBuffer(input_buffer);
//        if (raw_idx < 0 || raw_idx == prev_frame_index) {
//            input_mtx.unlock();
//            sleep_ms(40);
//            continue;
//        }
//        last_score_out = -1;
//        frame_index = raw_idx;
//        input_buffer += sizeof(int32_t);
//        fps = readInt32FromBuffer(input_buffer);
//        input_buffer += sizeof(int32_t) * 2;
//        int n_bytes = readInt32FromBuffer(input_buffer);
//        input_buffer += sizeof(int32_t);
//        std::vector<uint8_t> tmp(input_buffer, input_buffer + n_bytes);
//        if (tmp.empty()) {
//            input_mtx.unlock();
//            sleep_ms(40);
//            continue;
//        }
//
//        // decode frame
//        cv::Mat frame = cv::imdecode(tmp, cv::IMREAD_UNCHANGED);
//        input_mtx.unlock();
//        if (frame.empty()) {
//            sleep_ms(40);
//            continue;
//        }
//        int h = frame.rows, w = frame.cols;
//        if (w >= frame_width && h >= frame_height) {
//            int pad_x = (w - frame_width)/2;
//            frame = frame(cv::Rect(pad_x,0,frame_width,frame_height));
//        }
//        double ratio = double(max_size)/std::max(h,w);
////        if (ratio < 1)
////        {
////        int new_h = static_cast<int>(ratio * h);
////        int new_w = static_cast<int>(ratio * w);
////        cv::resize(frame, frame, cv::Size(new_w, new_h));
////        }
//
//        double t0 = double(cv::getTickCount());
//        cv::Mat frame_gray;
//        cv::cvtColor(frame, frame_gray, cv::COLOR_BGR2GRAY);
//        detect_only_mtx.lock();
//        detect_only = readInt32FromBuffer(detect_only_base);
//        detect_only_mtx.unlock();
//
//        if (detect_only)
//        {
////            single_time_call = true;
//            if (++calibration_check_counter >= CALIBRATION_CHECK_INTERVAL)
//            {
//                calibration_check_counter = 0;
//                try {
//                    last_detected_ellipses = calibration_detector._detect(frame_gray);
//                } catch (...) {
//                    int cnt = calibration_detector.process(frame, frame_gray);
//                    auto zone = calibration_detector.get_target_zone_info();
//                    last_detected_ellipses =
//                            zone.count("ellipses") ? zone["ellipses"] : std::vector<cv::RotatedRect>();
//                }
//                bool new_valid = false;
//                if (last_detected_ellipses.size() >= MIN_RINGS_REQUIRED)
//                {
//                    new_valid = true;
//                    for (auto &e : last_detected_ellipses)
//                    {
//                        float ar = std::max(e.size.width, e.size.height) /
//                                   std::min(e.size.width, e.size.height);
//                        if (ar >= MAX_ASPECT_RATIO) { new_valid = false; break; }
//                    }
//                }
//                setup_valid = new_valid;
//                platform_log("Calib valid: %zu rings? %s",
//                             last_detected_ellipses.size(),
//                             setup_valid?"yes":"no");
//            }
//            cv::Scalar ring_color;
//            if (setup_valid) {
//                ring_color = cv::Scalar(0, 255, 0);
//                cv::putText(frame, "Good setup! Switch to scoring to confirm",
//                            cv::Point(50, 70), cv::FONT_HERSHEY_SIMPLEX, 0.6, ring_color, 1);
////                cv::putText(frame, "Rings are circular and well detected",
////                            cv::Point(50, 100), cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 255, 255), 1);
//                circleCount = int(last_detected_ellipses.size());
//            }else {
//                ring_color = cv::Scalar(0, 0, 255);
//                cv::putText(frame, "Adjust camera to see target clearly",
//                            cv::Point(50, 70), cv::FONT_HERSHEY_SIMPLEX, 0.6, ring_color, 1);
////                cv::putText(frame, "Need at least 6 rings visible",
////                            cv::Point(50, 100), cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 255, 255), 1);
//                circleCount = 0;
//            }
//            for (auto &e : last_detected_ellipses)
//                cv::ellipse(frame, e, ring_color, 1);
//            last_score_out = -1;
//
//            // DRAW HISTORY EVEN IN CALIBRATION MODE
//            draw_history(frame);
//        }
//        else // SCORING MODE
//        {
//            if (!geometry_fixed)
//            {
//                if (setup_valid)
//                {
//                    for (int i=0; i<10; ++i)
//                        tz_detector.prepare(frame, frame_gray);
//                    geometry_fixed = true;
//                }
//                else
//                {
//                    cv::putText(frame, "Calibration required!", cv::Point(50,50),
//                                cv::FONT_HERSHEY_SIMPLEX, 0.8, cv::Scalar(0,0,255),2);
//                    circleCount = 0;
//                    last_score_out = -1;
//                }
//            }
//            if (geometry_fixed && !roi_initialized){
//                try {
//                    auto center = tz_detector.get_current_target_center();
//                    auto zone = tz_detector.get_target_zone_info();
//                    if (zone.count("ellipses"))
//                        tz_detector.enable_roi_mode(center, frame.size(), zone["ellipses"]);
//                } catch (...) {}
//                roi_initialized = true;
//            }
//            int numE = tz_detector.process(frame, frame_gray);
//            if (numE>0 && !tz_detector.is_shifting()){
//                auto rings = tz_detector.get_ellipses_for_scoring();
//                if (!rings.empty())
//                {
//                    cv::Rect roi = tz_detector.get_current_roi();
//                    cv::Point off(roi.x, roi.y);
//                    for (auto &e : rings)
//                    {
//                        cv::RotatedRect d = e;
//                        d.center.x += off.x;
//                        d.center.y += off.y;
//                        cv::ellipse(frame, d, cv::Scalar(255,255,255), 1);
//                    }
//                    cv::Mat pf = frame(roi), pg = frame_gray(roi);
////                    if (single_time_call) {
////                        for (int i=0; i<30; ++i)
////                            last_score_out = scorer.process(pf, pg, {{"ellipses",rings}}, frame_index * 33);
////                        single_time_call = false;
////                    }
////                    if(is_ble){
//                        size_t history_size_before = scorer.get_history().size();
//                        last_score_out = scorer.process(pf, pg, {{"ellipses",rings}}, frame_index * 33,is_ble);
//                        // Check if new shot was detected
//                        size_t history_size_after = scorer.get_history().size();
//
//                        if (history_size_after > history_size_before && last_score_out >= 0) {
//                            capture_shot(scorer, frame, off);
//                        }
//
////                    }else{
////                        last_score_out = -1;
////                    }
//
//                    // ALWAYS DRAW PERSISTENT HISTORY IN SCORING MODE
//                    draw_history(frame, off);
//                }
//            }
//            else {
//                last_score_out = -1;
//                circleCount = 0;
//
//                // DRAW HISTORY EVEN WHEN NOT PROCESSING SHOTS
//                draw_history(frame);
//            }
//
//            // draw score
////            int total = scorer.get_total_score();
////            std::string txt = "Last: " +
////                              std::string(last_score_out<0?"_":std::to_string(last_score_out)) +
////                              " Total: " + std::to_string(total);
////            cv::putText(frame, txt, cv::Point(50,120),
////                        cv::FONT_HERSHEY_COMPLEX, 0.7, cv::Scalar(0,255,0), 1);
//
//
//// 4) Now draw the list in reverse (newest first)
//            int count = 0;
//            if (globalList.empty()) {
//                cv::putText(frame, "Logs empty!", cv::Point(x, y0 + 2*lineHeight),
//                            fontFace, fontScale, cv::Scalar(0,255,255), thickness);
//            }
//            else {
//                for (auto it = globalList.rbegin(); it != globalList.rend(); ++it, ++count) {
//                    int y = y0 + count * lineHeight;
//                    if (y > frame.rows - 10) {
//                        platform_log("Reached bottom of frame at count=%d, y=%d; stopping draw",
//                                     count, y);
//                        break;
//                    }
////                    platform_log("Drawing list[%d] = '%s' at (%d,%d)",
////                                 count, it->c_str(), x, y);
//
//                    cv::putText(frame, *it, cv::Point(x, y),
//                                fontFace, fontScale, cv::Scalar(255,255,255), thickness);
//                }
//            }
//
//        }
//
//        double t1 = double(cv::getTickCount());
//        int runningFps = cvRound(cv::getTickFrequency()/(t1-t0));
//        cv::putText(frame, "#frame "+std::to_string(frame_index)+" fps:"+std::to_string(runningFps),
//                    cv::Point(200,50), cv::FONT_HERSHEY_COMPLEX, 0.7,
//                    cv::Scalar(0,255,0),1,cv::LINE_AA);
//
////        mtx.lock();
////        output_buffer = output_base;
////        std::memcpy(output_buffer, &frame_index, sizeof(frame_index));
////        output_buffer += sizeof(frame_index);
////        std::memcpy(output_buffer, &fps, sizeof(fps));
////        output_buffer += sizeof(fps);
////        int32_t out_score = detect_only ? circleCount : last_score_out;
////        std::memcpy(output_buffer, &out_score, sizeof(out_score));
////        output_buffer += sizeof(out_score);
////        std::vector<uchar> enc;
////        cv::imencode(".png", frame, enc);
////        int32_t sz = int32_t(enc.size());
////        std::memcpy(output_buffer, &sz, sizeof(sz));
////        output_buffer += sizeof(sz);
////        std::memcpy(output_buffer, enc.data(), sz);
////        mtx.unlock();
//
//// Inside your capture/send function:
////        if (ratio < 1)
////        {
////        cv::resize(frame, frame, cv::Size(frame_width, frame_height));
////        }
//        mtx.lock();
//        output_buffer = output_base;
//
//// 1) Frame index
//        std::memcpy(output_buffer, &frame_index, sizeof(frame_index));
//        output_buffer += sizeof(frame_index);
//
//// 2) FPS
//        std::memcpy(output_buffer, &fps, sizeof(fps));
//        output_buffer += sizeof(fps);
//
//// 3) Score
//        int32_t out_score = detect_only ? circleCount : last_score_out;
//        std::memcpy(output_buffer, &out_score, sizeof(out_score));
//        output_buffer += sizeof(out_score);
//
//// 4) Image data: either screenshot or live frame
//        if (last_score_out > 4) {
//            // Send the pre‐captured screenshot buffer
//            int32_t screenshot_sz = static_cast<int32_t>(g_screenshot_data.size());
//            std::memcpy(output_buffer, &screenshot_sz, sizeof(screenshot_sz));
//            output_buffer += sizeof(screenshot_sz);
//
//            std::memcpy(output_buffer, g_screenshot_data.data(), screenshot_sz);
//            output_buffer += screenshot_sz;
//        }
//        else {
//            // Encode current frame as PNG and send
//            std::vector<uchar> enc;
//            cv::imencode(".png", frame, enc);
//
//            int32_t sz = static_cast<int32_t>(enc.size());
//            std::memcpy(output_buffer, &sz, sizeof(sz));
//            output_buffer += sizeof(sz);
//
//            std::memcpy(output_buffer, enc.data(), sz);
//            output_buffer += sz;
//        }
//
//        mtx.unlock();
//
//    }
//    platform_log("Processing done in %dms", int(get_now()-start));
//    clearList();
//    is_running = false;
//    return 0;
//}
//


